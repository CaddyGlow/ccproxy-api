================
CODE SNIPPETS
================
TITLE: Pass Backend Options to AnyIO Run
DESCRIPTION: Illustrates how to pass backend-specific options to `anyio.run()` using the `backend_options` argument. Examples include enabling debug mode for asyncio and configuring interrupt handling for Trio.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_5

LANGUAGE: python
CODE:
```
run(main, backend="asyncio", backend_options={"debug": True})
run(
    main,
    backend="trio",
    backend_options={"restrict_keyboard_interrupt_to_checkpoints": True}
)
```

--------------------------------

TITLE: Install AnyIO
DESCRIPTION: Installs the AnyIO library using pip. This is the basic installation command.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_0

LANGUAGE: bash
CODE:
```
pip install anyio
```

--------------------------------

TITLE: Install AnyIO with Trio Backend
DESCRIPTION: Installs AnyIO along with the Trio backend as an extra dependency. This allows using Trio as the underlying asynchronous framework.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_1

LANGUAGE: bash
CODE:
```
pip install anyio[trio]
```

--------------------------------

TITLE: Run AnyIO Application
DESCRIPTION: Starts an AnyIO application by running the given async function. It handles the setup and teardown of the AnyIO runtime and the event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_0

LANGUAGE: Python
CODE:
```
anyio.run(async_function, backend='asyncio')
```

--------------------------------

TITLE: Install Pre-commit Hooks
DESCRIPTION: This command installs the pre-commit hooks for the AnyIO repository. Activating these hooks ensures that code style and quality checks are performed locally before committing changes.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_2

LANGUAGE: Shell
CODE:
```
pre-commit install
```

--------------------------------

TITLE: Start Task and Wait for Initialization in Python
DESCRIPTION: Shows how to start a task and wait for its initialization signal using `TaskGroup.start()` and `TaskStatus`. This is useful for services that need to be ready before dependent tasks proceed. The `task_status.started()` call is mandatory for the spawned task.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import (
    TASK_STATUS_IGNORED,
    create_task_group,
    connect_tcp,
    create_tcp_listener,
    run,
)
from anyio.abc import TaskStatus


async def handler(stream):
    ...


async def start_some_service(
    port: int, *, task_status: TaskStatus[None] = TASK_STATUS_IGNORED
):
    async with await create_tcp_listener(
        local_host="127.0.0.1", local_port=port
    ) as listener:
        task_status.started()
        await listener.serve(handler)


async def main():
    async with create_task_group() as tg:
        await tg.start(start_some_service, 5000)
        async with await connect_tcp("127.0.0.1", 5000) as stream:
            ...


run(main)
```

--------------------------------

TITLE: Start TLS Listener with AnyIO
DESCRIPTION: Sets up a TLS listener on a specified port and handles incoming connections using a provided handler function. Requires a TLS context.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from anyio import create_tcp_listener, run
from anyio.streams.tls import TLSListener

async def handle(client, server):
    # Handle client connection
    pass

async def main():
    # Assuming 'context' is a pre-configured SSL context
    listener = TLSListener(await create_tcp_listener(local_port=1234), context)
    await listener.serve(handle)

run(main)
```

--------------------------------

TITLE: Run Async Program with AnyIO (Default Backend)
DESCRIPTION: A simple AnyIO program that prints 'Hello, world!' and runs on the default backend (usually asyncio). It demonstrates the basic structure of an async function and how to execute it using `anyio.run()`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_2

LANGUAGE: python
CODE:
```
from anyio import run


async def main():
    print('Hello, world!')

run(main)
```

--------------------------------

TITLE: Run Async Program with Specific Backend (AnyIO)
DESCRIPTION: Shows how to explicitly specify the backend (e.g., 'trio' or 'asyncio') when running an async program with `anyio.run()`. This provides control over which asynchronous framework is used.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_3

LANGUAGE: python
CODE:
```
run(main, backend='trio')
run(main, backend='asyncio')
```

--------------------------------

TITLE: TaskGroup Start Method
DESCRIPTION: Adds the `TaskGroup.start()` method and the corresponding `BlockingPortal.start_task()` method. These allow for more explicit control over task initiation within task groups.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_163

LANGUAGE: Python
CODE:
```
anyio.TaskGroup.start()
```

LANGUAGE: Python
CODE:
```
anyio.BlockingPortal.start_task()
```

--------------------------------

TITLE: TLS Server Setup with SSL Context
DESCRIPTION: Demonstrates setting up a basic TLS server in Python using AnyIO and the `ssl` module. It includes creating an SSL context, loading a certificate and key, and handling client connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_6

LANGUAGE: Python
CODE:
```
import ssl

from anyio import create_tcp_listener, run
from anyio.streams.tls import TLSListener


async def handle(client):
    async with client:
        name = await client.receive()
        await client.send(b'Hello, %s\n' % name)


async def main():
    # Create a context for the purpose of authenticating clients
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

    # Load the server certificate and private key
    context.load_cert_chain(certfile='cert.pem', keyfile='key.pem')
```

--------------------------------

TITLE: Run Async Program using Native Trio Backend
DESCRIPTION: Demonstrates running an AnyIO-compatible async function directly using the native `trio.run()` function. It also shows how to identify the current async library using `sniffio.current_async_library()`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/basics.rst#_snippet_4

LANGUAGE: python
CODE:
```
import sniffio
import trio
from anyio import sleep


async def main():
    print('Hello')
    await sleep(1)
    print("I'm running on", sniffio.current_async_library())

trio.run(main)
```

--------------------------------

TITLE: AnyIO CapacityLimiter Example
DESCRIPTION: Illustrates the use of AnyIO's CapacityLimiter to control concurrent access to a limited resource. It shows how to initialize a limiter with a specific token count and how tasks acquire and release tokens.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_4

LANGUAGE: Python
CODE:
```
from anyio import CapacityLimiter, create_task_group, sleep, run


async def use_resource(tasknum, limiter):
    async with limiter:
        print(f"Task number {tasknum} is now working with the shared resource")
        await sleep(1)


async def main():
    limiter = CapacityLimiter(2)
    async with create_task_group() as tg:
        for num in range(10):
            tg.start_soon(use_resource, num, limiter)

run(main)
```

--------------------------------

TITLE: Start Task and Wait for Readiness (AnyIO)
DESCRIPTION: Demonstrates using `BlockingPortal.start_task` to start a task and wait for it to signal readiness by calling `task_status.started()`. This method returns both a future for the task's result and the initial start value provided by the task.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_6

LANGUAGE: Python
CODE:
```
from anyio import sleep, TASK_STATUS_IGNORED
from anyio.from_thread import start_blocking_portal


async def service_task(*, task_status=TASK_STATUS_IGNORED):
    task_status.started('STARTED')
    await sleep(1)
    return 'DONE'


with start_blocking_portal() as portal:
    future, start_value = portal.start_task(service_task)
    print('Task has started with value', start_value)

    return_value = future.result()
    print('Task has finished with return value', return_value)
```

--------------------------------

TITLE: File Read/Write Stream Example
DESCRIPTION: Shows how to use FileReadStream and FileWriteStream to read from and write to files. It demonstrates writing a byte string to a file and then reading it back, printing the content.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_4

LANGUAGE: Python
CODE:
```
from anyio import run
from anyio.streams.file import FileReadStream, FileWriteStream


async def main():
    path = '/tmp/testfile'
    async with await FileWriteStream.from_path(path) as stream:
        await stream.send(b'Hello, World!')

    async with await FileReadStream.from_path(path) as stream:
        async for chunk in stream:
            print(chunk.decode(), end='')

    print()

run(main)
```

--------------------------------

TITLE: AnyIO Task Group Resource Cleanup on Cancellation
DESCRIPTION: Demonstrates that a newly created task in AnyIO, even if cancelled immediately, gets an opportunity to react to the cancellation. This example shows a resource's __aexit__ method being called, printing 'closed'.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_7

LANGUAGE: Python
CODE:
```
import asyncio

import anyio


class Resource:
    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # Here would be the code that cleanly closes the resource
        print("closed")


async def handle_resource(resource):
    async with resource:
        ...


async def main():
    async with anyio.create_task_group() as tg:
        tg.start_soon(handle_resource, Resource())
        tg.cancel_scope.cancel()


# Output: "closed"
asyncio.run(main())
```

--------------------------------

TITLE: AnyIO Condition Example
DESCRIPTION: Demonstrates the usage of AnyIO's Condition primitive for synchronizing tasks. It shows how tasks can wait for a condition to be met and how to notify one or all waiting tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio import Condition, create_task_group, sleep, run


async def listen(tasknum, condition):
    async with condition:
        await condition.wait()
        print('Woke up task number', tasknum)


async def main():
    condition = Condition()
    async with create_task_group() as tg:
        for tasknum in range(6):
            tg.start_soon(listen, tasknum, condition)

        await sleep(1)
        async with condition:
            condition.notify(1)

        await sleep(1)
        async with condition:
            condition.notify(2)

        await sleep(1)
        async with condition:
            condition.notify_all()

run(main)
```

--------------------------------

TITLE: Buffered Byte Receive Stream Example
DESCRIPTION: Demonstrates the usage of BufferedByteReceiveStream for receiving data in chunks. It shows how to receive a specific number of bytes and how to receive data until a delimiter is encountered.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import run
from anyio.streams.buffered import BufferedByteReceiveStream
from anyio.streams.memory import create_memory_object_stream


async def main():
    send, receive = create_memory_object_stream[bytes](4)
    buffered = BufferedByteReceiveStream(receive)
    for part in b'hel', b'lo, ', b'wo', b'rld!':
        await send.send(part)

    result = await buffered.receive_exactly(8)
    print(repr(result))

    result = await buffered.receive_until(b'!', 10)
    print(repr(result))

run(main)
```

--------------------------------

TITLE: Text Stream Encoding/Decoding Example
DESCRIPTION: Illustrates how TextReceiveStream and TextSendStream can be used to seamlessly send and receive text data by handling the encoding and decoding of strings to bytes.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio import run, create_memory_object_stream
from anyio.streams.text import TextReceiveStream, TextSendStream


async def main():
    bytes_send, bytes_receive = create_memory_object_stream[bytes](1)
    text_send = TextSendStream(bytes_send)
    await text_send.send('åäö')
    result = await bytes_receive.receive()
    print(repr(result))

    text_receive = TextReceiveStream(bytes_receive)
    await bytes_send.send(result)
    result = await text_receive.receive()
    print(repr(result))

run(main)
```

--------------------------------

TITLE: Low-Level Temporary File and Directory Creation Asynchronously
DESCRIPTION: Provides an example of using lower-level asynchronous functions for temporary file and directory creation. It demonstrates mkstemp, mkdtemp, and gettempdir, highlighting that manual cleanup is required for mkstemp and mkdtemp.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tempfile.rst#_snippet_4

LANGUAGE: python
CODE:
```
from anyio import mkstemp, mkdtemp, gettempdir, run
import os

async def main():
    fd, path = await mkstemp(suffix=".txt", prefix="mkstemp_", text=True)
    print(f"Created temp file: {path}")

    temp_dir = await mkdtemp(prefix="mkdtemp_")
    print(f"Created temp dir: {temp_dir}")

    print(f"Default temp dir: {await gettempdir()}")

    os.remove(path)

run(main)
```

--------------------------------

TITLE: Handle KeyboardInterrupt and SystemExit with AnyIO in Python
DESCRIPTION: This example shows how to handle Ctrl+C (KeyboardInterrupt) and termination signals (SystemExit) by installing a custom signal handler using `anyio.open_signal_receiver`. It cancels the task group's scope upon receiving a signal.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/signals.rst#_snippet_1

LANGUAGE: Python
CODE:
```
import signal

from anyio import open_signal_receiver, create_task_group, run
from anyio.abc import CancelScope


async def signal_handler(scope: CancelScope):
    with open_signal_receiver(signal.SIGINT, signal.SIGTERM) as signals:
        async for signum in signals:
            if signum == signal.SIGINT:
                print('Ctrl+C pressed!')
            else:
                print('Terminated!')

            scope.cancel()
            return


async def main():
    async with create_task_group() as tg:
        tg.start_soon(signal_handler, tg.cancel_scope)
        ...  # proceed with starting the actual application logic

run(main)
```

--------------------------------

TITLE: AnyIO Event Notification Example
DESCRIPTION: Demonstrates how to use AnyIO Events to notify tasks. An event is set by one task and waited upon by another, facilitating communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import Event, create_task_group, run


async def notify(event):
    event.set()


async def main():
    event = Event()
    async with create_task_group() as tg:
        tg.start_soon(notify, event)
        await event.wait()
        print('Received notification!')

run(main)
```

--------------------------------

TITLE: Asyncio Task Cancellation Example
DESCRIPTION: Demonstrates a common issue with asyncio's edge cancellation where catching BaseException prevents proper task cancellation, leading to hangs. This example shows how a task catching CancelledError can continue execution unexpectedly.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_0

LANGUAGE: Python
CODE:
```
import asyncio


async def sleeper():
    try:
        await asyncio.sleep(1)
    except BaseException:
        pass  # the first cancellation is caught here

    # This call will never return unless the task is cancelled again
    await asyncio.sleep(float("inf"))

async def main():
    async with asyncio.TaskGroup() as tg:
        task = tg.create_task(sleeper())
        await asyncio.sleep(0)  # ensure that the task reaches the first sleep()
        task.cancel()

    print("done")

# Execution hangs
asyncio.run(main())
```

--------------------------------

TITLE: Asyncio TaskGroup Start Soon Consistency
DESCRIPTION: Ensures `TaskGroup.start_soon()` calls the target function immediately before starting the task for consistency across backends, and avoids coroutine wrappers on Python 3.8+.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_175

LANGUAGE: Python
CODE:
```
asyncio.TaskGroup.start_soon()
```

--------------------------------

TITLE: BlockingPortal Start Task Soon
DESCRIPTION: Introduces the `name` argument to `BlockingPortal.start_task_soon()`, formerly `spawn_task()`. This allows naming tasks for better debugging and identification.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_164

LANGUAGE: Python
CODE:
```
anyio.BlockingPortal.start_task_soon(name=...)
```

--------------------------------

TITLE: Open Process Handle for Interaction (Python)
DESCRIPTION: Launches a subprocess and provides a handle for more granular control over its input, output, and lifecycle. This example streams the stdout of the 'ps' command.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import open_process, run
from anyio.streams.text import TextReceiveStream


async def main():
    async with await open_process(['ps']) as process:
        async for text in TextReceiveStream(process.stdout):
            print(text)

run(main)
```

--------------------------------

TITLE: AnyIO Lock Exclusive Access Example
DESCRIPTION: Shows how to use AnyIO Locks for ensuring exclusive access to a shared resource. Only one task can acquire the lock and access the resource at any given time.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import Lock, create_task_group, sleep, run


async def use_resource(tasknum, lock):
    async with lock:
        print('Task number', tasknum, 'is now working with the shared resource')
        await sleep(1)


async def main():
    lock = Lock()
    async with create_task_group() as tg:
        for num in range(4):
            tg.start_soon(use_resource, num, lock)

run(main)
```

--------------------------------

TITLE: Get All Available AnyIO Backends
DESCRIPTION: Retrieves a list of all available backend names that AnyIO can use to run asynchronous code. This is useful for selecting a specific backend or for introspection.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_1

LANGUAGE: Python
CODE:
```
anyio.get_all_backends()
```

--------------------------------

TITLE: Start Blocking Portal for Thread Communication
DESCRIPTION: Initiates a blocking portal, which is a mechanism for safely communicating between synchronous threads and the asynchronous event loop. It allows threads to run async code.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_28

LANGUAGE: Python
CODE:
```
portal = anyio.from_thread.start_blocking_portal()
```

--------------------------------

TITLE: Fix RuntimeError: called 'started' twice on the same task status
DESCRIPTION: Corrects a 'RuntimeError: called 'started' twice on the same task status' that occurred when cancelling a task in a TaskGroup created with 'start()' before the first checkpoint after calling 'task_status.started()'.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_62

LANGUAGE: Python
CODE:
```
import anyio

async def task_with_early_cancel(task_status: anyio.abc.TaskStatus):
    try:
        task_status.started()
        # Simulate work before a potential cancellation point
        await anyio.sleep(0.01)
        # If cancelled here, the RuntimeError might occur if not handled properly
        await anyio.sleep(10)
    except anyio.get_cancelled_exc_class():
        print("Task was cancelled.")
        raise

async def run_taskgroup_with_start():
    async with anyio.create_task_group() as tg:
        # Using start() method which is sensitive to cancellation timing
        task_status = tg.start_soon(task_with_early_cancel)
        await anyio.sleep(0.001) # Ensure task_status.started() is called
        tg.cancel_scope.cancel()
        # The fix ensures this cancellation doesn't lead to the RuntimeError

# anyio.run(run_taskgroup_with_start)
```

--------------------------------

TITLE: Fix TaskGroup.start_soon() Type Annotation for Awaitables
DESCRIPTION: Corrects the type annotation for `TaskGroup.start_soon()` to properly accept any awaitables, ensuring type safety when starting asynchronous tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_96

LANGUAGE: python
CODE:
```
Fixed the type annotation of ``TaskGroup.start_soon()`` to accept any awaitables
  (already in v3.7.0 but was missing from 4.0.0rc1)
```

--------------------------------

TITLE: AnyIO Task Cancellation with Multiple Exceptions
DESCRIPTION: Demonstrates how AnyIO's cancel scopes deliver cancellation exceptions multiple times within a task, unlike asyncio's single delivery. This example shows a task that catches the first cancellation and then encounters another upon a subsequent await.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_5

LANGUAGE: Python
CODE:
```
import asyncio

import anyio


async def sleeper():
    try:
        await asyncio.sleep(1)
    except BaseException:
        pass  # the first cancellation is caught here

    # This will raise another CancelledError
    await asyncio.sleep(float("inf"))

async def main():
    async with anyio.create_task_group() as tg:
        tg.start_soon(sleeper)
        await asyncio.sleep(0)  # ensure that the task reaches the first sleep()
        tg.cancel_scope.cancel()

    print("done")

# Output: "done"
asyncio.run(main())
```

--------------------------------

TITLE: Get Temporary Directory Path
DESCRIPTION: Returns the path to the system's default temporary directory. This is useful for creating temporary files or directories in a standard location.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_36

LANGUAGE: Python
CODE:
```
temp_dir = anyio.gettempdir()
temp_dir_bytes = anyio.gettempdirb()
```

--------------------------------

TITLE: Send UDP Packet with Prepended Data
DESCRIPTION: Creates a UDP socket, listens for incoming packets, and sends a response back to the sender with 'Hello, ' prepended to the received data. This example demonstrates basic UDP communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_6

LANGUAGE: Python
CODE:
```
import socket

from anyio import create_udp_socket, run


async def main():
    async with await create_udp_socket(
        family=socket.AF_INET, local_port=1234
    ) as udp:
        async for packet, (host, port) in udp:
            await udp.sendto(b'Hello, ' + packet, host, port)

run(main)
```

--------------------------------

TITLE: Fix move_on_after and fail_after in AnyIO
DESCRIPTION: Version 1.4.0 resolves an issue where move_on_after() and fail_after() could get stuck on curio under certain circumstances.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_219

LANGUAGE: Python
CODE:
```
Fixed move_on_after() and fail_after() getting stuck on curio in some circumstances
```

--------------------------------

TITLE: Safe Task Group Usage in Async Context Managers
DESCRIPTION: Provides an example of a generally safe pattern for using task groups within asynchronous context managers, ensuring that the host task remains active throughout the enclosed operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_6

LANGUAGE: Python
CODE:
```
from contextlib import asynccontextmanager


# Okay in most cases!
@asynccontextmanager
async def some_context_manager():
    async with create_task_group() as tg:
        tg.start_soon(foo)
        yield
```

--------------------------------

TITLE: Network Address Information
DESCRIPTION: Provides functions to get address information for network sockets and to get the hostname and service name from socket addresses. These functions are essential for network programming.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_69

LANGUAGE: Python
CODE:
```
anyio.getaddrinfo
anyio.getnameinfo
```

--------------------------------

TITLE: Get Remote Address using Typed Attributes
DESCRIPTION: Demonstrates how to retrieve the remote IP address of a TCP connection using AnyIO's typed attributes. It connects to a host and port, then uses the `extra` method with `SocketAttribute.remote_address` to get the address.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import connect_tcp
from anyio.abc import SocketAttribute


async def connect(host, port, tls: bool):
    stream = await connect_tcp(host, port, tls=tls)
    print('Connected to', stream.extra(SocketAttribute.remote_address))
```

--------------------------------

TITLE: Send UNIX Datagram Packet with Prepended Data
DESCRIPTION: Creates a UNIX datagram socket, listens for incoming packets on a specified local path, and sends a response back to the sender with 'Hello, ' prepended. This mirrors the UDP example but uses file system paths.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_8

LANGUAGE: Python
CODE:
```
from anyio import create_unix_datagram_socket, run


async def main():
    async with await create_unix_datagram_socket(
        local_path='/tmp/mysock'
    ) as unix_dg:
        async for packet, path in unix_dg:
            await unix_dg.sendto(b'Hello, ' + packet, path)

run(main)
```

--------------------------------

TITLE: AnyIO Semaphore Resource Limiting Example
DESCRIPTION: Illustrates using AnyIO Semaphores to limit concurrent access to a shared resource. A semaphore with an initial value of 2 allows only two tasks to access the resource at a time.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import Semaphore, create_task_group, sleep, run


async def use_resource(tasknum, semaphore):
    async with semaphore:
        print(f"Task number {tasknum} is now working with the shared resource")
        await sleep(1)


async def main():
    semaphore = Semaphore(2)
    async with create_task_group() as tg:
        for num in range(10):
            tg.start_soon(use_resource, num, semaphore)

run(main)
```

--------------------------------

TITLE: Fix TaskGroup.start() Cancellation Issues on Asyncio
DESCRIPTION: Addresses two bugs related to TaskGroup.start() on asyncio: erroneous RuntimeError when cancelling a task before checkpoint, and cancellation of the entire group if a start() call is cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_63

LANGUAGE: Python
CODE:
```
import anyio

async def task_that_might_be_cancelled(task_status: anyio.abc.TaskStatus):
    task_status.started()
    await anyio.sleep(10) # Keep task alive

async def test_taskgroup_start_cancellation():
    async with anyio.create_task_group() as tg:
        # Scenario 1: Cancel task before checkpoint
        task_status = tg.start_soon(task_that_might_be_cancelled)
        await anyio.sleep(0.001) # Ensure task_status.started() is called
        tg.cancel_scope.cancel() # This should not raise RuntimeError

        # Scenario 2: Cancel the start() call itself (conceptual)
        # This scenario is harder to directly simulate as start() is synchronous.
        # The fix ensures that if the task spawned by start() is cancelled,
        # it doesn't cascade to cancel the whole group incorrectly.

# anyio.run(test_taskgroup_start_cancellation)
```

--------------------------------

TITLE: Start Blocking Portal for External Threads (AnyIO)
DESCRIPTION: Demonstrates how to initiate a blocking portal to allow external threads to interact with an AnyIO event loop. `anyio.from_thread.start_blocking_portal` is used to create a portal, which can then be used to call methods on the event loop from other threads.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio.from_thread import start_blocking_portal


with start_blocking_portal(backend='trio') as portal:
    portal.call(...)
```

--------------------------------

TITLE: Asyncio Resource Management with TaskGroup Cancellation
DESCRIPTION: Demonstrates a scenario where a task responsible for resource management is cancelled before it can properly close the resource. This highlights a problem in asyncio's cancellation handling when tasks are cancelled before they start.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_2

LANGUAGE: Python
CODE:
```
import asyncio


class Resource:
    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # Here would be the code that cleanly closes the resource
        print("closed")


async def handle_resource(resource):
    async with resource:
        ...


async def main():
    async with asyncio.TaskGroup() as tg:
        task = tg.create_task(handle_resource(Resource()))
        task.cancel()


# No output
asyncio.run(main())
```

--------------------------------

TITLE: Get Default Interpreter Limiter
DESCRIPTION: Retrieves the default limiter that controls the maximum number of subinterpreters that can be active concurrently. This helps manage resource consumption.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_22

LANGUAGE: Python
CODE:
```
limiter = anyio.to_interpreter.current_default_interpreter_limiter()
```

--------------------------------

TITLE: Fix BlockingPortal Tasks Not Notifying Sync Listeners
DESCRIPTION: Corrects an issue where tasks started from `BlockingPortal` did not notify synchronous listeners (e.g., `concurrent.futures.wait()`) when they were cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_93

LANGUAGE: python
CODE:
```
Fixed tasks started from ``BlockingPortal`` not notifying synchronous listeners
  (``concurrent.futures.wait()``) when they're cancelled
```

--------------------------------

TITLE: Build AnyIO Documentation with Tox
DESCRIPTION: This command uses tox to build the project's documentation. The generated HTML documentation will be available in the 'build' directory.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_1

LANGUAGE: Shell
CODE:
```
tox -e docs
```

--------------------------------

TITLE: Get Current Effective Deadline
DESCRIPTION: Retrieves the deadline of the innermost cancel scope that is currently active. This allows tasks to be aware of any imposed time limits.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_14

LANGUAGE: Python
CODE:
```
deadline = anyio.current_effective_deadline()
```

--------------------------------

TITLE: Get Current Time in AnyIO
DESCRIPTION: Returns the current time according to the AnyIO event loop's clock. This is useful for timing operations or for logging.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_6

LANGUAGE: Python
CODE:
```
anyio.current_time()
```

--------------------------------

TITLE: Get Default Process Limiter
DESCRIPTION: Retrieves the default limiter that controls the maximum number of worker processes that can be used. This is essential for managing system resources when using multiprocessing.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_24

LANGUAGE: Python
CODE:
```
limiter = anyio.to_process.current_default_process_limiter()
```

--------------------------------

TITLE: Get Current Task Function
DESCRIPTION: Introduces the `anyio.get_current_task()` function. This function returns information about the currently executing task, providing a way to introspect the task's context.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_234

LANGUAGE: Python
CODE:
```
import anyio

async def inspect_current_task():
    current_task = anyio.get_current_task()
    print(f"Current Task ID: {current_task.id}")
```

--------------------------------

TITLE: Run AnyIO Tests with Tox
DESCRIPTION: This snippet demonstrates how to use tox to run the AnyIO test suite, including pre-commit checks. It also shows how to run checks on all environments in parallel.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_0

LANGUAGE: Shell
CODE:
```
tox
tox -p
```

--------------------------------

TITLE: Get AnyIO Cancelled Exception Class
DESCRIPTION: Returns the specific exception class that AnyIO uses to signal cancellation. This allows for precise exception handling when dealing with cancelled operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_2

LANGUAGE: Python
CODE:
```
anyio.get_cancelled_exc_class()
```

--------------------------------

TITLE: Add Keyword Arguments for run_process and open_process
DESCRIPTION: Extends 'run_process()' and 'open_process()' with support for additional keyword arguments: 'startupinfo', 'creationflags', 'pass_fds', 'user', 'group', 'extra_groups', and 'umask'.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_49

LANGUAGE: Python
CODE:
```
import anyio
import sys

async def run_process_with_extra_args():
    # Example using startupinfo (Windows specific)
    startupinfo = None
    if sys.platform == "win32":
        startupinfo = anyio.subprocess.STARTUPINFO()
        startupinfo.dwFlags |= anyio.subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = anyio.subprocess.SW_HIDE

    try:
        # Example with user and group (Unix-like systems)
        await anyio.run_process("ls",
                              user="nobody",
                              group="nogroup",
                              startupinfo=startupinfo)

        # Example with creationflags (Windows specific)
        # await anyio.run_process("cmd.exe",
        #                       creationflags=anyio.subprocess.CREATE_NEW_PROCESS_GROUP)

    except Exception as e:
        print(f"Error running process: {e}")

async def open_process_with_extra_args():
    try:
        process = await anyio.open_process("cat",
                                           user="nobody",
                                           group="nogroup")
        await process.wait()
    except Exception as e:
        print(f"Error opening process: {e}")
```

--------------------------------

TITLE: Run async generator fixtures in single task for pytest plugin
DESCRIPTION: Modifies the pytest plugin to execute both setup and teardown phases of asynchronous generator fixtures within a single task. This enables use cases like cancel scopes and task groups that span the yield point.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_118

LANGUAGE: Python
CODE:
```
# pytest plugin configuration or implementation detail
# Ensures proper lifecycle management for async fixtures.
```

--------------------------------

TITLE: Run Sync Function in Worker Interpreter with AnyIO
DESCRIPTION: Demonstrates how to execute a CPU-intensive function in a separate worker interpreter using AnyIO's `to_interpreter.run_sync`. This is suitable for parallelizing Python code that heavily utilizes the CPU and does not rely on releasing the GIL. The example shows importing necessary modules, defining an async main function, calling `run_sync` with the target function and its arguments, and printing the result.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/subinterpreters.rst#_snippet_0

LANGUAGE: Python
CODE:
```
import time

from anyio import run, to_interpreter

from yourothermodule import cpu_intensive_function

async def main():
    result = await to_interpreter.run_sync(
        cpu_intensive_function, 'Hello, ', 'world!'
    )
    print(result)

run(main)
```

--------------------------------

TITLE: Get Cancelled Exception Class
DESCRIPTION: Replaces the direct use of `CancelledError` with `anyio.get_cancelled_exc_class()`. This function returns the appropriate cancellation exception class for the current backend, ensuring consistent cancellation handling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_235

LANGUAGE: Python
CODE:
```
import anyio

try:
    # Some operation that might be cancelled
    pass
except anyio.get_cancelled_exc_class():
    print("Operation was cancelled")
```

--------------------------------

TITLE: Abstract Network Client with Connectables
DESCRIPTION: Demonstrates creating a network client that abstracts the connection mechanism using AnyIO's Connectable interfaces. It shows how to handle different connection types like host/port or UNIX socket paths.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_10

LANGUAGE: Python
CODE:
```
from os import PathLike
from ssl import SSLContext

from anyio.abc import ByteStreamConnectable, as_connectable


class MyNetworkClient:
    def __init__(
        self,
        connectable: ByteStreamConnectable | tuple[str, int] | str | PathLike[str],
        tls: bool | SSLContext = False
    ):
        self.connectable = as_connectable(connectable, tls)

    async def __aenter__(self):
        # Connect to the remote and enter the stream's context manager
        self._stream = await self.connectable.connect()
        await self._stream.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # Exit the stream's context manager, thus disconnecting it
        await self._stream.__aexit__(exc_type, exc_val, exc_tb)
```

--------------------------------

TITLE: Asyncio Cancellation and Lost Results Example
DESCRIPTION: Illustrates how cancelling an asyncio task that is about to resume with a value can lead to the loss of that result. The CancelledError is raised upon resumption, potentially skipping the intended data processing.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_1

LANGUAGE: Python
CODE:
```
import asyncio


async def receive(f):
    print(await f)
    await asyncio.sleep(1)
    print("The task will be cancelled before this is printed")


async def main():
    f = asyncio.get_running_loop().create_future()
    task = asyncio.create_task(receive(f))
    await asyncio.sleep(0)  # make sure the task has started
    f.set_result("hello")
    task.cancel()

    # The "hello" result is lost due to the cancellation
    try:
        await task
    except asyncio.CancelledError:
        pass


# No output
asyncio.run(main())
```

--------------------------------

TITLE: Add current_time() Function
DESCRIPTION: Introduces the `anyio.current_time()` function, which returns the current time according to the AnyIO event loop. This provides a consistent way to get the current time across different backends.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_261

LANGUAGE: Python
CODE:
```
import anyio

async def get_current_time():
    now = anyio.current_time()
    print(f"Current time: {now}")
```

--------------------------------

TITLE: Create TemporaryDirectory Asynchronously
DESCRIPTION: Demonstrates the asynchronous creation of a temporary directory. It prints the path of the created directory, which is automatically cleaned up upon exiting the 'async with' block.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tempfile.rst#_snippet_3

LANGUAGE: python
CODE:
```
from anyio import TemporaryDirectory, run

async def main():
    async with TemporaryDirectory() as temp_dir:
        print(f"Temporary directory path: {temp_dir}")

run(main)
```

--------------------------------

TITLE: Get Current Default Thread Limiter
DESCRIPTION: Introduces the `anyio.current_default_thread_limiter()` function. This function provides access to the currently active default thread limiter, which can be used for managing thread pool execution.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_225

LANGUAGE: Python
CODE:
```
import anyio

async def use_thread_limiter():
    thread_limiter = anyio.current_default_thread_limiter()
    # Use the limiter to run tasks in threads
```

--------------------------------

TITLE: Add start_new_session to run_process() and open_process()
DESCRIPTION: Introduces the 'start_new_session' keyword argument to run_process() and open_process(), allowing for greater control over process creation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_119

LANGUAGE: Python
CODE:
```
from anyio import run_process

# Example usage:
# run_process('my_script.py', start_new_session=True)
```

--------------------------------

TITLE: Get Default Thread Limiter for Worker Threads
DESCRIPTION: Retrieves the default limiter that controls the maximum number of worker threads that can be used for running synchronous functions. This helps manage resource usage.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_20

LANGUAGE: Python
CODE:
```
limiter = anyio.to_thread.current_default_thread_limiter()
```

--------------------------------

TITLE: Create and Use TemporaryFile Asynchronously
DESCRIPTION: Demonstrates the creation and usage of an asynchronous TemporaryFile. It writes content, seeks to the beginning, and reads the content back. The file is automatically deleted upon closure.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tempfile.rst#_snippet_0

LANGUAGE: python
CODE:
```
from anyio import TemporaryFile, run

async def main():
    async with TemporaryFile(mode="w+") as f:
        await f.write("Temporary file content")
        await f.seek(0)
        print(await f.read())  # Output: Temporary file content

run(main)
```

--------------------------------

TITLE: AnyIO ResourceGuard Usage
DESCRIPTION: Demonstrates how to use AnyIO's ResourceGuard to ensure exclusive access to a resource. It shows how to initialize a ResourceGuard within a class and use it as a context manager to prevent concurrent access.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/synchronization.rst#_snippet_5

LANGUAGE: Python
CODE:
```
from anyio import ResourceGuard, BusyResourceError

class Resource:
    def __init__(self):
        self._guard = ResourceGuard()

    async def do_something() -> None:
        with self._guard:
            ...

# Example of how it would be used:
# async def main():
#     resource = Resource()
#     try:
#         await resource.do_something()
#     except BusyResourceError:
#         print("Resource is busy")
```

--------------------------------

TITLE: Create and Manage Tasks with Task Groups in Python
DESCRIPTION: Demonstrates how to create multiple concurrent tasks using `create_task_group` and `start_soon`. Tasks run concurrently, and the task group ensures all tasks are finished before exiting the context. If any task raises an exception, others are cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import sleep, create_task_group, run


async def sometask(num: int) -> None:
    print('Task', num, 'running')
    await sleep(1)
    print('Task', num, 'finished')


async def main() -> None:
    async with create_task_group() as tg:
        for num in range(5):
            tg.start_soon(sometask, num)

    print('All tasks finished!')

run(main)
```

--------------------------------

TITLE: Test Echo Server with Free TCP Port
DESCRIPTION: An asynchronous test function demonstrating how to use the 'free_tcp_port' fixture to set up an echo server and test a client connection. It creates a TCP listener on the provided free port, handles client connections, and sends/receives data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_7

LANGUAGE: python
CODE:
```
from anyio import connect_tcp, create_task_group, create_tcp_listener
from anyio.abc import SocketStream


async def test_echo(free_tcp_port: int) -> None:
    async def handle(client_stream: SocketStream) -> None:
        async with client_stream:
            payload = await client_stream.receive()
            await client_stream.send(payload[::-1])

    async with (
        await create_tcp_listener(local_port=free_tcp_port) as listener,
        create_task_group() as tg
    ):
        tg.start_soon(listener.serve, handle)

        async with await connect_tcp("127.0.0.1", free_tcp_port) as stream:
            await stream.send(b"hello")
            assert await stream.receive() == b"olleh"

        tg.cancel_scope.cancel()
```

--------------------------------

TITLE: Git Workflow for Pull Requests
DESCRIPTION: This sequence of git commands outlines the process for creating a new branch, making changes, committing them with a message that references an issue if applicable, and pushing the changes to a forked repository.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contributing.rst#_snippet_3

LANGUAGE: Shell
CODE:
```
git clone git@github.com/yourusername/anyio
git checkout -b myfixname
git push
```

--------------------------------

TITLE: Instantiate Event directly in AnyIO 3
DESCRIPTION: Shows the migration from using `create_event()` to directly instantiating `Event` in AnyIO 3. This simplifies the creation of synchronization primitives.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_10

LANGUAGE: Python
CODE:
```
from anyio import Event

async def main():
    event = Event()
```

--------------------------------

TITLE: Pytest Fixture for Setting Up and Tearing Down a Server
DESCRIPTION: An asynchronous pytest fixture that sets up a server, yields control, and then shuts down the server. It depends on the 'anyio_backend' fixture.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_6

LANGUAGE: python
CODE:
```
@pytest.fixture(scope='module')
async def server(anyio_backend):
    server = await setup_server()
    yield
    await server.shutdown()
```

--------------------------------

TITLE: Create TCP Listener
DESCRIPTION: Creates a TCP listener that binds to a specified host and port, ready to accept incoming connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_66

LANGUAGE: Python
CODE:
```
listener = await anyio.create_tcp_listener(local_address=('127.0.0.1', 8000))
```

--------------------------------

TITLE: Receive SIGTERM and SIGHUP Signals in Python
DESCRIPTION: This snippet demonstrates how to use `anyio.open_signal_receiver` to listen for SIGTERM and SIGHUP signals. It shows how to gracefully shut down on SIGTERM and reload configuration on SIGHUP.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/signals.rst#_snippet_0

LANGUAGE: Python
CODE:
```
import signal

from anyio import open_signal_receiver, run


async def main():
    with open_signal_receiver(signal.SIGTERM, signal.SIGHUP) as signals:
        async for signum in signals:
            if signum == signal.SIGTERM:
                return
            elif signum == signal.SIGHUP:
                print('Reloading configuration')

run(main)
```

--------------------------------

TITLE: Add env and cwd to run_process() and open_process()
DESCRIPTION: Introduces ``env`` and ``cwd`` keyword arguments to the ``run_process()`` and ``open_process()`` functions, allowing for environment variable and current working directory configuration.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_151

LANGUAGE: Python
CODE:
```
Added ``env`` and ``cwd`` keyword arguments to ``run_process()`` and ``open_process()``.
```

--------------------------------

TITLE: Fix to_process.run_sync() Initialization Failure
DESCRIPTION: Resolves an issue where 'to_process.run_sync()' failed to initialize correctly if '__main__.__file__' pointed to a file in a nonexistent directory.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_52

LANGUAGE: Python
CODE:
```
import anyio
import os

# This is a conceptual example. The actual fix is within AnyIO's implementation.
# To test this, one would need to simulate the condition described.

def sync_function():
    print("Running sync function.")

async def run_sync_in_process():
    # Simulate the condition where __main__.__file__ might be problematic
    original_main_file = os.environ.get('__MAIN_FILE__')
    os.environ['__MAIN_FILE__'] = '/nonexistent/path/__main__.py'

    try:
        await anyio.to_process.run_sync(sync_function)
    except Exception as e:
        print(f"Caught expected error: {e}")
    finally:
        # Restore original value
        if original_main_file is not None:
            os.environ['__MAIN_FILE__'] = original_main_file
        else:
            del os.environ['__MAIN_FILE__']

# To run this, you would typically call:
# anyio.run(run_sync_in_process)
```

--------------------------------

TITLE: Create and Use Memory Object Stream (Python)
DESCRIPTION: Demonstrates creating a memory object stream for producer-consumer patterns. It shows how to send objects through the stream and receive them asynchronously, with tasks processing items from the stream.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import create_task_group, create_memory_object_stream, run
from anyio.streams.memory import MemoryObjectReceiveStream


async def process_items(receive_stream: MemoryObjectReceiveStream[str]) -> None:
    async with receive_stream:
        async for item in receive_stream:
            print('received', item)


async def main():
    # The [str] specifies the type of the objects being passed through the
    # memory object stream. This is a bit of trick, as create_memory_object_stream
    # is actually a class masquerading as a function.
    send_stream, receive_stream = create_memory_object_stream[str]()
    async with create_task_group() as tg:
        tg.start_soon(process_items, receive_stream)
        async with send_stream:
            for num in range(10):
                await send_stream.send(f'number {num}')

run(main)
```

--------------------------------

TITLE: Use start_blocking_portal as context manager in AnyIO 3
DESCRIPTION: Demonstrates the required usage of `start_blocking_portal` as a context manager in AnyIO 3. This change affects how blocking operations are managed within AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_9

LANGUAGE: Python
CODE:
```
from anyio import sleep
from anyio.from_thread import start_blocking_portal

with start_blocking_portal() as portal:
    portal.call(sleep, 1)
```

--------------------------------

TITLE: Open Signal Receiver (AnyIO)
DESCRIPTION: Provides an alternative mechanism for handling signals using a context manager. This allows for more flexible signal handling compared to asyncio's add_signal_handler.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_16

LANGUAGE: Python
CODE:
```
async with anyio.open_signal_receiver(signalnums: Iterable[int]) as signals:
```

--------------------------------

TITLE: Create Unix Domain Socket Listener
DESCRIPTION: Creates a listener for Unix domain sockets, binding to a specified file path.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_67

LANGUAGE: Python
CODE:
```
listener = await anyio.create_unix_listener('/tmp/my_server.sock')
```

--------------------------------

TITLE: Test Echo Server Using Ephemeral Port Discovery
DESCRIPTION: An asynchronous test function that demonstrates setting up an echo server and testing a client connection without explicitly using a free port fixture. It creates a TCP listener, retrieves the assigned ephemeral port, and then connects a client to it.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_8

LANGUAGE: python
CODE:
```
from anyio import connect_tcp, create_task_group, create_tcp_listener
from anyio.abc import SocketAttribute, SocketStream

async def test_echo() -> None:
    async def handle(client_stream: SocketStream) -> None:
        async with client_stream:
            payload = await client_stream.receive()
            await client_stream.send(payload[::-1])

    async with (
        await create_tcp_listener(local_host="127.0.0.1") as listener,
        create_task_group() as tg
    ):
        tg.start_soon(listener.serve, handle)
        port = listener.extra(SocketAttribute.local_port)

        async with await connect_tcp("127.0.0.1", port) as stream:
            await stream.send(b"hello")
            assert await stream.receive() == b"olleh"

        tg.cancel_scope.cancel()
```

--------------------------------

TITLE: Temporary Directory Context Manager
DESCRIPTION: Provides a context manager for temporary directories, ensuring they are created and automatically removed along with their contents upon exiting the context.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_39

LANGUAGE: Python
CODE:
```
async with await anyio.TemporaryDirectory() as temp_dir:
    print(f'Using temp dir: {temp_dir}')
```

--------------------------------

TITLE: Task Information and Management
DESCRIPTION: Includes utilities for inspecting and managing tasks, such as retrieving task information, listing running tasks, and waiting for tasks to become blocked. Also includes a pytest plugin for managing free ports.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_77

LANGUAGE: Python
CODE:
```
anyio.TaskInfo
anyio.pytest_plugin.FreePortFactory
anyio.get_current_task
anyio.get_running_tasks
anyio.wait_all_tasks_blocked
```

--------------------------------

TITLE: Handle Specific Exceptions in AnyIO TaskGroup
DESCRIPTION: Demonstrates how to use the `catch` context manager within an AnyIO task group to handle specific exceptions like `ValueError` and `KeyError`. Each exception type can be associated with a dedicated handler function.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_4

LANGUAGE: Python
CODE:
```
import anyio
from anyio import create_task_group, catch

def handle_valueerror(excgroup: ExceptionGroup) -> None:
    # handle each ValueError
    pass

def handle_keyerror(excgroup: ExceptionGroup) -> None:
    # handle each KeyError
    pass

async def some_task():
    pass

async def another_task():
    pass

async def main():
    with catch({
        ValueError: handle_valueerror,
        KeyError: handle_keyerror
    }):
        async with create_task_group() as tg:
            tg.start_soon(some_task)
            tg.start_soon(another_task)
```

--------------------------------

TITLE: Configure AnyIO Backend in conftest.py (Python)
DESCRIPTION: Customize the AnyIO backend and its options for tests by defining the `anyio_backend` fixture in your `conftest.py` file. This allows specifying a default backend or multiple backends with specific configurations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_2

LANGUAGE: python
CODE:
```
import pytest


@pytest.fixture
def anyio_backend():
    return 'asyncio'
```

LANGUAGE: python
CODE:
```
import pytest


@pytest.fixture(params=[
    pytest.param(('asyncio', {'use_uvloop': True}), id='asyncio+uvloop'),
    pytest.param(('asyncio', {'use_uvloop': False}), id='asyncio'),
    pytest.param(('trio', {'restrict_keyboard_interrupt_to_checkpoints': True}), id='trio')
])
def anyio_backend(request):
    return request.param
```

LANGUAGE: python
CODE:
```
import pytest


@pytest.mark.parametrize('anyio_backend', ['asyncio'])
async def test_on_asyncio_only(anyio_backend):
    ...
```

--------------------------------

TITLE: Context Manager Mix-in
DESCRIPTION: A mix-in class that provides the standard Python context manager protocol (`__enter__`, `__exit__`) for classes. It simplifies the creation of context managers.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_40

LANGUAGE: Python
CODE:
```
class MyContextManager(anyio.ContextManagerMixin):
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
```

--------------------------------

TITLE: Fix TaskGroup.start() Cancellation Responsiveness on Asyncio
DESCRIPTION: Addresses an issue where `TaskGroup.start()` on the asyncio backend did not properly respond to external cancellation requests.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_92

LANGUAGE: python
CODE:
```
Fixed ``TaskGroup.start()`` on asyncio not responding to cancellation from the outside
```

--------------------------------

TITLE: Using Custom Event Loop Factory with AnyIO
DESCRIPTION: Shows how to configure AnyIO's `run` function to use a custom event loop factory, such as one provided by `uvloop`. This replaces the older method of specifying an event loop policy, aligning with AnyIO 4's approach.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_5

LANGUAGE: Python
CODE:
```
anyio.run(main, backend_options={"loop_factory": uvloop.new_event_loop})
```

--------------------------------

TITLE: Subclassing ContextManagerMixin with Superclass Call
DESCRIPTION: Demonstrates how a subclass can inherit from and call the implementation of a parent class that uses ContextManagerMixin. The `with super().__contextmanager__():` syntax ensures the parent's context logic is executed.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_3

LANGUAGE: python
CODE:
```
from collections.abc import Generator
from contextlib import contextmanager
from typing import Self

from anyio import ContextManagerMixin

class SuperclassContextManager(ContextManagerMixin):
    @contextmanager
    def __contextmanager__(self) -> Generator[Self]:
        print("superclass entered")
        try:
            yield self
        finally:
            print("superclass exited")


class SubclassContextManager(SuperclassContextManager):
    @contextmanager
    def __contextmanager__(self) -> Generator[Self]:
        print("subclass entered")
        try:
            with super().__contextmanager__():
                yield self
        finally:

```

--------------------------------

TITLE: Create UNIX Socket Listener (AnyIO)
DESCRIPTION: Creates a listener for UNIX domain sockets using a file path and serves incoming client connections. This is used for local IPC on UNIX-like systems.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio import create_unix_listener, run


async def handle(client):
    async with client:
        name = await client.receive(1024)
        await client.send(b'Hello, %s\n' % name)


async def main():
    listener = await create_unix_listener('/tmp/mysock')
    await listener.serve(handle)

run(main)
```

--------------------------------

TITLE: Connect via TCP
DESCRIPTION: Establishes a TCP connection to a specified host and port. Returns a byte stream for communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_64

LANGUAGE: Python
CODE:
```
stream = await anyio.connect_tcp('example.com', 80)
```

--------------------------------

TITLE: Temporary File Context Manager
DESCRIPTION: Provides a context manager for temporary files, ensuring they are properly created, used, and deleted. Supports both named and unnamed temporary files.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_37

LANGUAGE: Python
CODE:
```
async with await anyio.TemporaryFile() as temp_file:
    await temp_file.write(b'content')
async with await anyio.NamedTemporaryFile() as named_temp_file:
    await named_temp_file.write(b'named content')
```

--------------------------------

TITLE: Create a Temporary Directory Asynchronously
DESCRIPTION: Creates a temporary directory asynchronously. The directory and its contents are automatically removed when the returned context manager exits.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_35

LANGUAGE: Python
CODE:
```
async with await anyio.mkdtemp() as temp_dir_path:
    print(f'Created temporary directory: {temp_dir_path}')
```

--------------------------------

TITLE: Process Management
DESCRIPTION: Provides functions to run and open subprocesses, allowing for external command execution and interaction. It also defines the abstract base class for processes.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_73

LANGUAGE: Python
CODE:
```
anyio.run_process
anyio.open_process
anyio.abc.Process
```

--------------------------------

TITLE: Asynchronous Context Manager Mix-in
DESCRIPTION: A mix-in class that provides the asynchronous context manager protocol (`__aenter__`, `__aexit__`) for classes. It simplifies the creation of asynchronous context managers.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_41

LANGUAGE: Python
CODE:
```
class MyAsyncContextManager(anyio.AsyncContextManagerMixin):
    async def __aenter__(self):
        return self
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        pass
```

--------------------------------

TITLE: Create and Use SpooledTemporaryFile Asynchronously
DESCRIPTION: Shows how to asynchronously create and use a SpooledTemporaryFile. This is useful for small data kept in memory. It writes content, seeks, and reads it back.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tempfile.rst#_snippet_2

LANGUAGE: python
CODE:
```
from anyio import SpooledTemporaryFile, run

async def main():
    async with SpooledTemporaryFile(max_size=1024, mode="w+") as f:
        await f.write("Spooled temp file content")
        await f.seek(0)
        print(await f.read())

run(main)
```

--------------------------------

TITLE: Compatibility Helper for Collapsing Exception Groups
DESCRIPTION: Provides a Python context manager to maintain compatibility between AnyIO 3 and AnyIO 4 regarding exception handling. This helper unwraps single-exception `BaseExceptionGroup` instances, allowing older code expecting direct exceptions to function correctly.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_3

LANGUAGE: Python
CODE:
```
import sys
from contextlib import contextmanager
from typing import Generator

has_exceptiongroups = True
if sys.version_info < (3, 11):
    try:
        from exceptiongroup import BaseExceptionGroup
    except ImportError:
        has_exceptiongroups = False


@contextmanager
def collapse_excgroups() -> Generator[None, None, None]:
    try:
        yield
    except BaseException as exc:
        if has_exceptiongroups:
            while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:
                exc = exc.exceptions[0]

        raise exc
```

--------------------------------

TITLE: Create TCP Listener (AnyIO)
DESCRIPTION: Creates a TCP listener on a specified local port and serves incoming client connections. It uses `create_tcp_listener` and the `serve` method from AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import create_tcp_listener, run


async def handle(client):
    async with client:
        name = await client.receive(1024)
        await client.send(b'Hello, %s\n' % name)


async def main():
    listener = await create_tcp_listener(local_port=1234)
    await listener.serve(handle)

run(main)
```

--------------------------------

TITLE: Create a Task Group
DESCRIPTION: Creates a task group, which is a context manager for spawning and managing concurrent asynchronous tasks. All tasks within a group are guaranteed to finish before the group exits.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_16

LANGUAGE: Python
CODE:
```
async with anyio.create_task_group() as tg:
    await tg.spawn(some_async_function)
    await tg.spawn(another_async_function)
```

--------------------------------

TITLE: Write Bytes to File Asynchronously with AnyIO Path
DESCRIPTION: Demonstrates creating a file and writing binary content to it asynchronously using AnyIO's `Path` class. The `write_bytes` operation is awaited as it performs disk I/O in a worker thread.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio import Path, run


async def main():
    path = Path('/foo/bar')
    await path.write_bytes(b'hello, world')

run(main)
```

--------------------------------

TITLE: Add anyio.Path.is_junction() and anyio.Path.walk() Methods
DESCRIPTION: New methods `anyio.Path.is_junction()` and `anyio.Path.walk()` have been added to the `anyio.Path` object, providing enhanced file system path manipulation capabilities.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_85

LANGUAGE: python
CODE:
```
Added the ``anyio.Path.is_junction()`` and ``anyio.Path.walk()`` methods
```

--------------------------------

TITLE: Implement Async Context Manager with Nested Task Group
DESCRIPTION: This Python code demonstrates how to create a custom async context manager using `AsyncContextManagerMixin`. It shows the manual implementation of the `__asynccontextmanager__` method, which yields the context manager instance after launching tasks within an `anyio.create_task_group`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from __future__ import annotations

from collections.abc import AsyncGenerator
from typing import Self

from anyio import AsyncContextManagerMixin, create_task_group


class MyAsyncContextManager(AsyncContextManagerMixin):
    @asynccontextmanager
    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:
        async with create_task_group() as tg:
            ...  # launch tasks
            yield self
```

--------------------------------

TITLE: Synchronous Context Manager with ContextManagerMixin
DESCRIPTION: Demonstrates how to create a synchronous context manager using AnyIO's ContextManagerMixin. It utilizes the @contextmanager decorator on the __contextmanager__ method to define the context entry and exit logic.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_0

LANGUAGE: python
CODE:
```
from collections.abc import Generator
from contextlib import contextmanager
from typing import Self

from anyio import ContextManagerMixin

class MyContextManager(ContextManagerMixin):
    @contextmanager
    def __contextmanager__(self) -> Generator[Self]:
        print("entering context")
        yield self
        print("exiting context")
```

--------------------------------

TITLE: Connect to TLS Server with AnyIO
DESCRIPTION: Establishes a TLS connection to a localhost server on port 1234. It demonstrates loading custom CA certificates for verification and sending/receiving data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_8

LANGUAGE: Python
CODE:
```
import ssl
from anyio import connect_tcp, run

async def main():
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    context.load_verify_locations(cafile='cert.pem')

    async with await connect_tcp('localhost', 1234, ssl_context=context) as client:
        await client.send(b'Client\n')
        response = await client.receive()
        print(response)

run(main)
```

--------------------------------

TITLE: Cross-compatible Event creation for AnyIO 2 and 3
DESCRIPTION: Provides a method for creating `Event` objects that works with both AnyIO 2 and AnyIO 3, using a try-except block to handle the different import mechanisms.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_11

LANGUAGE: Python
CODE:
```
try:
    from anyio import Event
    create_event = Event
except ImportError:
    from anyio.abc import Event
    create_event = lambda: Event()
```

--------------------------------

TITLE: Add stdin argument to anyio.run_process()
DESCRIPTION: Enhances `anyio.run_process()` by adding a `stdin` argument, similar to `anyio.open_process()`, `asyncio.create_subprocess_…()`, `trio.run_process()`, and `subprocess.run()`. This allows providing standard input to the subprocess.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_15

LANGUAGE: Python
CODE:
```
import anyio

# async def run_with_stdin():
#     result = await anyio.run_process(['cat'], stdin=b'hello')
#     print(result.stdout)

```

--------------------------------

TITLE: Use maybe_async for Event.set in AnyIO 3
DESCRIPTION: Demonstrates how to use `maybe_async` to handle the change where `Event.set()` is no longer awaitable in AnyIO 3. This ensures compatibility with older versions while adapting to the new API.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_6

LANGUAGE: Python
CODE:
```
from anyio.abc import Event
from anyio import maybe_async


async def foo(event: Event):
    await maybe_async(event.set())
    ...
```

--------------------------------

TITLE: Connect via Unix Domain Socket
DESCRIPTION: Establishes a connection to a Unix domain socket. This is typically used for inter-process communication on Unix-like systems.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_65

LANGUAGE: Python
CODE:
```
stream = await anyio.connect_unix('/tmp/mysocket.sock')
```

--------------------------------

TITLE: Share Blocking Portal with BlockingPortalProvider
DESCRIPTION: Demonstrates using `BlockingPortalProvider` to efficiently share a single blocking portal across multiple threads for on-demand asynchronous calls. This avoids the overhead of creating a new portal for each synchronous API call.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_10

LANGUAGE: Python
CODE:
```
from anyio.from_thread import BlockingPortalProvider

class MyAPI:
    def __init__(self, async_obj) -> None:
        self._async_obj = async_obj
        self._portal_provider = BlockingPortalProvider()

    def do_stuff(self) -> None:
        with self._portal_provider as portal:
            portal.call(self._async_obj.do_async_stuff)
```

--------------------------------

TITLE: Use Asynchronous Fixtures with AnyIO (Python)
DESCRIPTION: Define asynchronous fixtures using `async def` and the `pytest.mark.anyio` marker or by depending on the `anyio_backend` fixture. This is useful for setting up and tearing down asynchronous resources for tests.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_3

LANGUAGE: python
CODE:
```
import pytest

pytestmark = pytest.mark.anyio


@pytest.fixture
async def server():
    server = await setup_server()
    yield server
    await server.shutdown()


async def test_server(server):
    result = await server.do_something()
    assert result == 'foo'
```

LANGUAGE: python
CODE:
```
import pytest


@pytest.fixture(autouse=True)
async def server(anyio_backend):
    server = await setup_server()
    yield
    await server.shutdown()


async def test_server():
    result = await client.do_something_on_the_server()
    assert result == 'foo'
```

--------------------------------

TITLE: Read File Asynchronously with AnyIO
DESCRIPTION: Demonstrates how to open a file asynchronously using `anyio.open_file`, read its contents, and print them. This operation is performed in a worker thread to avoid blocking the event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import open_file, run


async def main():
    async with await open_file('/some/path/somewhere') as f:
        contents = await f.read()
        print(contents)

run(main)
```

--------------------------------

TITLE: Create AnyIO Event
DESCRIPTION: Demonstrates how to create an AnyIO event. This function is part of the core AnyIO library and handles asynchronous event synchronization.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_12

LANGUAGE: Python
CODE:
```
from anyio import create_event
from anyio.abc import Event

async def foo() -> Event:
    return create_event()
```

--------------------------------

TITLE: Signal Handling
DESCRIPTION: Enables the opening of signal receivers to handle operating system signals asynchronously. This is important for graceful shutdown and signal-based control flow.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_75

LANGUAGE: Python
CODE:
```
anyio.open_signal_receiver
```

--------------------------------

TITLE: Add BlockingPortalProvider Class
DESCRIPTION: Introduces the 'BlockingPortalProvider' class, designed to simplify the creation of synchronous counterparts for asynchronous interfaces that would otherwise necessitate multiple blocking portals.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_59

LANGUAGE: Python
CODE:
```
import anyio

class MyAsyncService:
    async def do_something(self):
        await anyio.sleep(0.1)
        return "Async result"

# Using BlockingPortalProvider to create a sync interface
class MySyncService:
    def __init__(self):
        self._portal_provider = anyio.BlockingPortalProvider()
        self._async_service = self._portal_provider.wrap_async(MyAsyncService())

    def do_something_sync(self):
        return self._async_service.do_something()

# Example usage:
# sync_service = MySyncService()
# result = sync_service.do_something_sync()
# print(result)
```

--------------------------------

TITLE: Use maybe_async_cm for CancelScope in AnyIO 3
DESCRIPTION: Shows how to use `maybe_async_cm` for context managers like `CancelScope` that have transitioned from async to regular context managers in AnyIO 3. This allows for compatible usage across AnyIO versions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from anyio import CancelScope, maybe_async_cm

async def foo():
    async with maybe_async_cm(CancelScope()) as scope:
        ...
```

--------------------------------

TITLE: Convert to Connectable
DESCRIPTION: Converts various network address representations into a connectable object, which can then be used to establish connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_63

LANGUAGE: Python
CODE:
```
connectable = anyio.as_connectable(('localhost', 8080))
```

--------------------------------

TITLE: Handle Multiple Exceptions with except* in Python
DESCRIPTION: Illustrates how to catch multiple exceptions raised within a task group using the `except*` syntax available in Python 3.11+. This allows handling different exception types that might occur concurrently.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import create_task_group

try:
    async with create_task_group() as tg:
        tg.start_soon(some_task)
        tg.start_soon(another_task)
except* ValueError as excgroup:
    for exc in excgroup.exceptions:
        ...  # handle each ValueError
except* KeyError as excgroup:
    for exc in excgroup.exceptions:
        ...  # handle each KeyError
```

--------------------------------

TITLE: Wrap Async Context Manager with Blocking Portal
DESCRIPTION: Demonstrates how to wrap an asynchronous context manager into a synchronous one using `BlockingPortal.wrap_async_context_manager`. This allows using async context managers within synchronous code blocks managed by AnyIO's blocking portal.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from anyio.from_thread import start_blocking_portal


class AsyncContextManager:
    async def __aenter__(self):
        print('entering')

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print('exiting with', exc_type)


async_cm = AsyncContextManager()
with start_blocking_portal() as portal, portal.wrap_async_context_manager(async_cm):
    print('inside the context manager block')
```

--------------------------------

TITLE: Provide free TCP/UDP port fixtures for pytest
DESCRIPTION: Adds four new fixtures to the AnyIO pytest plugin for easily obtaining unused TCP and UDP ports. These fixtures (`free_tcp_port_factory`, `free_udp_port_factory`, `free_tcp_port`, `free_udp_port`) simplify network testing by providing reliable access to available ports.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_14

LANGUAGE: Python
CODE:
```
pytest_plugins = ['anyio']

def test_with_free_tcp_port(free_tcp_port):
    assert free_tcp_port > 0

def test_with_port_factory(free_tcp_port_factory):
    port1 = free_tcp_port_factory()
    port2 = free_tcp_port_factory()
    assert port1 != port2

```

--------------------------------

TITLE: Creating Type Annotated Memory Object Streams (AnyIO 4)
DESCRIPTION: Demonstrates the updated syntax for creating type-annotated memory object streams in AnyIO 4. The `create_memory_object_stream` function is now a generic class, requiring type parameters to be specified using square brackets.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_4

LANGUAGE: Python
CODE:
```
send, receive = create_memory_object_stream[int](100)
```

--------------------------------

TITLE: Configure Pytest for AnyIO (TOML)
DESCRIPTION: Configure pytest to automatically detect and run AnyIO tests by setting `anyio_mode = "auto"` in the pytest configuration file.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_0

LANGUAGE: toml
CODE:
```
[tool.pytest.ini_options]
anyio_mode = "auto"
```

--------------------------------

TITLE: OpenSSL Command for Self-Signed Certificate
DESCRIPTION: Provides the bash command to generate a self-signed X.509 certificate and a private key using OpenSSL, suitable for local development and testing TLS connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_5

LANGUAGE: Bash
CODE:
```
openssl req -x509 -newkey rsa:2048 -subj '/CN=localhost' -keyout key.pem -out cert.pem -nodes -days 365
```

--------------------------------

TITLE: Receive File Descriptor via UNIX Socket (AnyIO Client)
DESCRIPTION: A client that connects to a UNIX socket, receives a file descriptor, opens it using `os.fdopen`, and prints its content.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_4

LANGUAGE: Python
CODE:
```
import os

from anyio import connect_unix, run


async def main():
    async with await connect_unix('/tmp/mysock') as client:
        _, fds = await client.receive_fds(0, 1)
        with os.fdopen(fds[0]) as file:
            print(file.read())

run(main)
```

--------------------------------

TITLE: Add async support for temporary file handling
DESCRIPTION: Introduces asynchronous support for temporary file operations, allowing temporary files to be created and managed within an async context. This integrates seamlessly with AnyIO's asynchronous I/O model.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_13

LANGUAGE: Python
CODE:
```
import anyio

# async def manage_temp_file():
#     async with await anyio.tempfile.TemporaryFile() as tmp:
#         await tmp.write(b'some data')
#         await tmp.seek(0)
#         content = await tmp.read()
#         print(content)

```

--------------------------------

TITLE: Text Stream Wrappers
DESCRIPTION: Provides stream wrappers for handling text data, including encoding and decoding. These simplify working with text over byte-oriented protocols.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_59

LANGUAGE: Python
CODE:
```
text_receive_stream = anyio.streams.text.TextReceiveStream(byte_stream)
text_send_stream = anyio.streams.text.TextSendStream(byte_stream)
```

--------------------------------

TITLE: Create and Use NamedTemporaryFile Asynchronously
DESCRIPTION: Illustrates the asynchronous creation and use of a NamedTemporaryFile. It prints the file's name, writes content, seeks to the beginning, and reads the content. The file is deleted upon closure if delete=True.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tempfile.rst#_snippet_1

LANGUAGE: python
CODE:
```
from anyio import NamedTemporaryFile, run

async def main():
    async with NamedTemporaryFile(mode="w+", delete=True) as f:
        print(f"Temporary file name: {f.name}")
        await f.write("Named temp file content")
        await f.seek(0)
        print(await f.read())

run(main)
```

--------------------------------

TITLE: Wrap Synchronous File Object Asynchronously with AnyIO
DESCRIPTION: Illustrates how to wrap an existing synchronous file object into an asynchronous one using `anyio.wrap_file`. This allows using asynchronous iteration with files opened using the standard `open()` function.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import wrap_file, run


async def main():
    with open('/some/path/somewhere') as f:
        async for line in wrap_file(f):
            print(line, end='')

run(main)
```

--------------------------------

TITLE: Create a Temporary File Asynchronously
DESCRIPTION: Creates a temporary file asynchronously, returning its path and an asynchronous file object. The file is automatically deleted when closed.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_34

LANGUAGE: Python
CODE:
```
async with await anyio.mkstemp() as (file, path):
    await file.write(b'temp data')
```

--------------------------------

TITLE: Instantiate Event and CapacityLimiter outside event loop
DESCRIPTION: Allows the Event and CapacityLimiter classes to be instantiated without requiring an active event loop thread, providing more flexibility in their usage.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_68

LANGUAGE: Python
CODE:
```
from anyio import Event, CapacityLimiter

event = Event()
limiter = CapacityLimiter(10)
```

--------------------------------

TITLE: BlockingPortal Spawn Task and Wrap Context Manager
DESCRIPTION: Adds `spawn_task()` and `wrap_async_context_manager()` methods to `BlockingPortal`. These provide utilities for managing tasks and context managers in a blocking manner.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_187

LANGUAGE: Python
CODE:
```
anyio.BlockingPortal.spawn_task()
```

LANGUAGE: Python
CODE:
```
anyio.BlockingPortal.wrap_async_context_manager()
```

--------------------------------

TITLE: Asynchronous Path Operations
DESCRIPTION: Provides an asynchronous interface for path manipulation and file system operations, similar to `pathlib.Path` but with async methods.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_33

LANGUAGE: Python
CODE:
```
async_path = anyio.Path('my_directory')
await async_path.mkdir()
await async_path.unlink()
```

--------------------------------

TITLE: Update type annotations for run_process() and open_process()
DESCRIPTION: Updates type annotations for run_process() and open_process(). 'command' now accepts bytes and sequences of bytes, and 'stdin', 'stdout', 'stderr' accept file-like objects.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_117

LANGUAGE: Python
CODE:
```
from typing import Sequence, BinaryIO
from anyio import run_process, open_process

# Example:
# run_process(['ls', '-l'], stdin=open('input.txt', 'rb'))
# run_process(command=['echo', 'hello'], stdout=...) # command can be bytes
```

--------------------------------

TITLE: Catching Cancellation Exceptions with get_cancelled_exc_class
DESCRIPTION: Shows how to specifically catch the cancellation exception raised by AnyIO using get_cancelled_exc_class. It emphasizes the importance of re-raising the caught exception for correct application behavior.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_4

LANGUAGE: Python
CODE:
```
from anyio import get_cancelled_exc_class


async def do_something():
    try:
        await run_async_stuff()
    except get_cancelled_exc_class():
        # (perform cleanup)
        raise
```

--------------------------------

TITLE: Asynchronous Context Manager with AsyncContextManagerMixin
DESCRIPTION: Illustrates the creation of an asynchronous context manager using AnyIO's AsyncContextManagerMixin. The @asynccontextmanager decorator is applied to the __asynccontextmanager__ method for defining asynchronous context entry and exit.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_1

LANGUAGE: python
CODE:
```
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Self

from anyio import AsyncContextManagerMixin

class MyAsyncContextManager(AsyncContextManagerMixin):
    @asynccontextmanager
    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:
        print("entering context")
        yield self
        print("exiting context")
```

--------------------------------

TITLE: Catching Specific Exceptions from Task Groups (Python 3.11+)
DESCRIPTION: Demonstrates how to catch specific exceptions like ValueError when they are raised from a task group in AnyIO 4 using the `except*` syntax, which is available in Python 3.11 and later. This syntax allows for handling multiple exceptions within an ExceptionGroup.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_0

LANGUAGE: Python
CODE:
```
try:
    await function_using_a_taskgroup()
except* ValueError as excgrp:
    # Note: excgrp is an ExceptionGroup now!
    ...
```

--------------------------------

TITLE: Shielding Operations with CancelScope
DESCRIPTION: Demonstrates how to use CancelScope with shield=True to protect operations from cancellation. This is often combined with move_on_after or fail_after for controlled timeouts during cleanup.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_3

LANGUAGE: Python
CODE:
```
async with create_task_group() as tg:
    with CancelScope(shield=True) as scope:
        tg.start_soon(external_task)
        tg.cancel_scope.cancel()
        print('Started sleeping in the host task')
        await sleep(1)
        print('Finished sleeping in the host task')
```

LANGUAGE: Python
CODE:
```
async def do_something(resource):
    try:
        ...
    except BaseException:
        # Here we wait 10 seconds for resource.aclose() to complete,
        # but if the operation doesn't complete within that period, we move on
        # and re-raise the caught exception anyway
        with move_on_after(10, shield=True):
            await resource.aclose()

        raise
```

--------------------------------

TITLE: Mark Tests with pytest.mark.anyio (Python)
DESCRIPTION: Mark individual asynchronous test functions or entire modules/classes with the `pytest.mark.anyio` marker to enable AnyIO's test runner.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_1

LANGUAGE: python
CODE:
```
import pytest

pytestmark = pytest.mark.anyio

async def test_something():
    ...
```

LANGUAGE: python
CODE:
```
import pytest


async def test_something(anyio_backend):
    ...
```

--------------------------------

TITLE: Wrap existing sockets as AnyIO streams
DESCRIPTION: Provides class methods to wrap existing sockets into AnyIO stream objects. This allows seamless integration of pre-existing socket resources with AnyIO's asynchronous stream abstractions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio.streams.uds import UNIXSocketStream
from anyio.streams.socket import SocketStream, UDPSocket, ConnectedUDPSocket
from anyio.abc import SocketListener

# Example usage:
# existing_socket = ... # obtain an existing socket
# stream = SocketStream.from_socket(existing_socket)
# unix_stream = UNIXSocketStream.from_socket(existing_socket)
# udp_socket = UDPSocket.from_socket(existing_socket)
# connected_udp_socket = ConnectedUDPSocket.from_socket(existing_socket)
# listener = SocketListener.from_socket(existing_socket)

```

--------------------------------

TITLE: Iterate File Lines Asynchronously with AnyIO
DESCRIPTION: Shows how to asynchronously iterate over a file line by line using `anyio.open_file` and an `async for` loop. This is useful for processing large files without loading them entirely into memory.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import open_file, run


async def main():
    async with await open_file('/some/path/somewhere') as f:
        async for line in f:
            print(line, end='')

run(main)
```

--------------------------------

TITLE: Multi Listener for Streams
DESCRIPTION: A listener that can manage multiple underlying listeners, allowing a single point of entry to accept connections from various sources.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_56

LANGUAGE: Python
CODE:
```
multi_listener = anyio.streams.stapled.MultiListener([listener1, listener2])
```

--------------------------------

TITLE: Improved Asynchronous Context Manager with Task Group
DESCRIPTION: Shows a corrected implementation of an asynchronous context manager that properly handles task group cleanup. This version uses `async with create_task_group()` within the `__asynccontextmanager__` to ensure the task group is exited even if errors occur during context entry.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_2

LANGUAGE: python
CODE:
```
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Self

from anyio import AsyncContextManagerMixin, create_task_group

class MyBetterContextManager(AsyncContextManagerMixin):
    @asynccontextmanager
    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:
        async with create_task_group() as task_group:
            # Still crashes, but at least now the task group is exited
            task_group.start_soon(self.my_background_func)
            yield self

    async my_background_func(self, arg: int) -> None:
        ...
```

--------------------------------

TITLE: Add Path copy and move methods
DESCRIPTION: Includes `copy()`, `copy_into()`, `move()`, and `move_into()` methods for the `anyio.Path` class, available in Python 3.14.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_23

LANGUAGE: Python
CODE:
```
Added support for the ``copy()``, ``copy_into()``, ``move()`` and ``move_into()``
  methods in ``anyio.Path``, available in Python 3.14
```

--------------------------------

TITLE: Connect to UNIX Socket (AnyIO)
DESCRIPTION: Connects to a UNIX domain socket using a file path, sends data, and receives a response. This is an alternative to TCP for local inter-process communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import connect_unix, run


async def main():
    async with await connect_unix('/tmp/mysock') as client:
        await client.send(b'Client\n')
        response = await client.receive(1024)
        print(response)

run(main)
```

--------------------------------

TITLE: Pytest Fixture for AnyIO Backend
DESCRIPTION: A pytest fixture that specifies the AnyIO backend to be used for testing, typically returning 'asyncio'.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_5

LANGUAGE: python
CODE:
```
def anyio_backend():
    return 'asyncio'
```

--------------------------------

TITLE: Add Python 3.13 Path Methods to anyio.Path
DESCRIPTION: Provides support for 'from_uri()', 'full_match()', and 'parser' methods/properties in anyio.Path, which were newly added in Python 3.13.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_48

LANGUAGE: Python
CODE:
```
import anyio
import sys

async def use_new_path_methods(uri):
    if sys.version_info >= (3, 13):
        p = await anyio.Path.from_uri(uri)
        print(f"Parsed path: {p}")
        # Assuming 'parser' is a property or method that can be accessed
        # print(f"Parser: {p.parser}")
        # Assuming 'full_match' is a method
        # if await p.full_match("/some/pattern"):
        #     print("Full match found.")
    else:
        print("Python 3.13 path methods are not available on this version.")

# Example usage:
# await use_new_path_methods("file:///path/to/file")
```

--------------------------------

TITLE: AnyIO Task Cancellation Before Resuming
DESCRIPTION: Illustrates how a task in AnyIO can process the result of an await before being cancelled. This is shown by setting a future's result and then cancelling the task group, ensuring the 'hello' message is printed.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_6

LANGUAGE: Python
CODE:
```
import asyncio

import anyio


async def receive(f):
    print(await f)
    await asyncio.sleep(1)
    print("The task will be cancelled before this is printed")


async def main():
    f = asyncio.get_running_loop().create_future()
    async with anyio.create_task_group() as tg:
        tg.start_soon(receive, f)
        await asyncio.sleep(0)  # make sure the task has started
        f.set_result("hello")
        tg.cancel_scope.cancel()


# Output: "hello"
asyncio.run(main())
```

--------------------------------

TITLE: Python AsyncContextManagerMixin Subclassing
DESCRIPTION: This snippet demonstrates subclassing AnyIO's AsyncContextManagerMixin. It shows how to create nested asynchronous context managers, ensuring proper entry and exit messages are printed for both the superclass and subclass contexts.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/contextmanagers.rst#_snippet_4

LANGUAGE: python
CODE:
```
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Self

from anyio import AsyncContextManagerMixin

class SuperclassContextManager(AsyncContextManagerMixin):
    @asynccontextmanager
    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:
        print("superclass entered")
        try:
            yield self
        finally:
            print("superclass exited")


class SubclassContextManager(SuperclassContextManager):
    @asynccontextmanager
    async def __asynccontextmanager__(self) -> AsyncGenerator[Self]:
        print("subclass entered")
        try:
            async with super().__asynccontextmanager__():
                yield self
        finally:
            print("subclass exited")
```

--------------------------------

TITLE: Improve Type Annotations for PathLike in run_process/open_process
DESCRIPTION: Enhances type annotations and support for 'PathLike' arguments in 'run_process()' and 'open_process()', allowing path-like objects similar to 'subprocess.Popen'.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_50

LANGUAGE: Python
CODE:
```
import anyio
from pathlib import Path

async def run_with_pathlike():
    path_obj = Path("/path/to/executable")
    try:
        # Using a Path object as an argument
        await anyio.run_process(path_obj, "arg1")
    except Exception as e:
        print(f"Error: {e}")

async def open_with_pathlike():
    path_obj = Path("/path/to/executable")
    try:
        # Using a Path object as an argument
        process = await anyio.open_process(path_obj)
        await process.wait()
    except Exception as e:
        print(f"Error: {e}")
```

--------------------------------

TITLE: Allow EventAdapter set() before binding
DESCRIPTION: Modifies `EventAdapter` to permit calling `set()` even before an async backend is bound to it.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_29

LANGUAGE: Python
CODE:
```
Changed ``EventAdapter`` (an ``Event`` with no bound async backend) to allow ``set()``
  to work even before an async backend is bound to it
  (`#819 <https://github.com/agronholm/anyio/issues/819>`_)
```

--------------------------------

TITLE: Create context manager mix-ins for AnyIO
DESCRIPTION: Introduces `anyio.ContextManagerMixin` and `anyio.AsyncContextManagerMixin` to simplify the creation of classes that embed other context managers, such as cancel scopes or task groups. This aids in managing resource lifecycles within asynchronous operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_2

LANGUAGE: Python
CODE:
```
import anyio

class MyAsyncContextManager(anyio.AsyncContextManagerMixin):
    async def __aenter__(self):
        # enter logic
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # exit logic
        pass

# Example usage:
# async with MyAsyncContextManager():
#     pass

```

--------------------------------

TITLE: Run One-Shot Command in Shell (Python)
DESCRIPTION: Executes an external command using the default shell. This is equivalent to `shell=True` in Python's `subprocess.run`. The command is provided as a string.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import run_process, run


async def main():
    result = await run_process('ps')
    print(result.stdout.decode())

run(main)
```

--------------------------------

TITLE: Asyncio StreamWriter get_extra_info
DESCRIPTION: The get_extra_info method in asyncio's StreamWriter returns a dictionary, making type checking difficult and requiring manual key access for retrieving information like remote addresses. AnyIO offers a more type-safe approach.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_12

LANGUAGE: Python
CODE:
```
writer.get_extra_info('socket')
```

--------------------------------

TITLE: Add Support for Hypothesis
DESCRIPTION: Adds built-in support for the Hypothesis library. This integration allows for property-based testing of AnyIO code, enabling the discovery of edge cases and potential bugs through randomized testing.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_236

LANGUAGE: Python
CODE:
```
import pytest
import hypothesis
import anyio

@hypothesis.given(data=hypothesis.strategies.integers())
@pytest.mark.anyio
async def test_integer_processing(data):
    # Test logic using Hypothesis and AnyIO
```

--------------------------------

TITLE: Memory Object Stream Implementations
DESCRIPTION: Provides concrete implementations for memory-based object streams, used for efficient in-process communication between tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_54

LANGUAGE: Python
CODE:
```
send_stream = anyio.streams.memory.MemoryObjectSendStream()
receive_stream = anyio.streams.memory.MemoryObjectReceiveStream(send_stream)
```

--------------------------------

TITLE: Catching Specific Exceptions from Task Groups (with exceptiongroup backport)
DESCRIPTION: Shows how to handle specific exceptions raised from AnyIO 4 task groups using the `exceptiongroup` backport library for compatibility with Python versions older than 3.11. It utilizes the `catch` context manager to specify how different exception types should be handled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from exceptiongroup import ExceptionGroup, catch

def handle_value_errors(excgrp: ExceptionGroup) -> None:
    ...

with catch({ValueError: handle_value_errors}):
    await function_using_a_taskgroup()
```

--------------------------------

TITLE: Synchronization Primitives
DESCRIPTION: Offers various synchronization primitives for managing concurrent tasks, including Events, Locks, Conditions, Semaphores, and Capacity Limiters. Statistics classes are also provided for monitoring these primitives.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_74

LANGUAGE: Python
CODE:
```
anyio.Event
anyio.Lock
anyio.Condition
anyio.Semaphore
anyio.CapacityLimiter
anyio.ResourceGuard
anyio.LockStatistics
anyio.EventStatistics
anyio.ConditionStatistics
anyio.CapacityLimiterStatistics
anyio.SemaphoreStatistics
```

--------------------------------

TITLE: Create Blocking Portal within Running Event Loop (AnyIO)
DESCRIPTION: Shows how to create a `BlockingPortal` instance when an event loop is already running. This allows handing off the portal to external threads, enabling them to interact with the active event loop. The portal is managed using an asynchronous context manager.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_4

LANGUAGE: Python
CODE:
```
from anyio import run
from anyio.from_thread import BlockingPortal


async def main():
    async with BlockingPortal() as portal:
        # ...hand off the portal to external threads...
        await portal.sleep_until_stopped()

run(main)
```

--------------------------------

TITLE: Add wrap_file() Function
DESCRIPTION: Introduces the ``wrap_file()`` function, which allows wrapping existing files to be used as asynchronous file objects within AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_137

LANGUAGE: Python
CODE:
```
Added the ``wrap_file()`` function for wrapping existing files as asynchronous file
  objects
```

--------------------------------

TITLE: Make TaskStatus a generic protocol
DESCRIPTION: The TaskStatus class is now a generic protocol, allowing it to be parametrized to specify the type of value passed to task_status.started().

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_103

LANGUAGE: Python
CODE:
```
from typing import Generic, TypeVar
from anyio.abc import TaskStatus

T = TypeVar('T')

class MyTaskStatus(TaskStatus[T]):
    def started(self, value: T) -> None:
        pass
```

--------------------------------

TITLE: Open an Asynchronous File
DESCRIPTION: Opens a file asynchronously, allowing read and write operations without blocking the event loop. This is the asynchronous equivalent of Python's built-in `open()`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_30

LANGUAGE: Python
CODE:
```
async with await anyio.open_file('myfile.txt', mode='w') as f:
    await f.write('Hello, world!')
```

--------------------------------

TITLE: Connect to TCP Socket (AnyIO)
DESCRIPTION: Establishes a connection to a remote TCP socket, sends data, and receives a response. It uses the `connect_tcp` function from the AnyIO library.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import connect_tcp, run


async def main():
    async with await connect_tcp('hostname', 1234) as client:
        await client.send(b'Client\n')
        response = await client.receive()
        print(response)

run(main)
```

--------------------------------

TITLE: No-Wait Acquire Methods
DESCRIPTION: Adds `acquire_nowait()` methods to `Lock`, `Condition`, and `Semaphore`. These allow attempting to acquire a resource without blocking, returning immediately if the resource is unavailable.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_167

LANGUAGE: Python
CODE:
```
anyio.Lock.acquire_nowait()
```

LANGUAGE: Python
CODE:
```
anyio.Condition.acquire_nowait()
```

LANGUAGE: Python
CODE:
```
anyio.Semaphore.acquire_nowait()
```

--------------------------------

TITLE: Generate Self-Signed Certificates with trustme for TLS
DESCRIPTION: Provides pytest fixtures to generate a Certificate Authority (CA) and issue server/client certificates using the trustme library. These are useful for testing TLS services.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_9

LANGUAGE: Python
CODE:
```
import ssl
import pytest
import trustme

@pytest.fixture(scope='session')
def ca():
    return trustme.CA()

@pytest.fixture(scope='session')
def server_context(ca):
    server_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    ca.issue_cert('localhost').configure_cert(server_context)
    return server_context

@pytest.fixture(scope='session')
def client_context(ca):
    client_context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    ca.configure_trust(client_context)
    return client_context
```

--------------------------------

TITLE: Synchronous Send with Memory Object Stream (Python)
DESCRIPTION: Illustrates how to perform a synchronous send operation on a memory object stream using the `send_nowait` method within a context manager.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio.streams.memory import MemoryObjectSendStream


def synchronous_callback(send_stream: MemoryObjectSendStream[str]) -> None:
    with send_stream:
        send_stream.send_nowait('hello')
```

--------------------------------

TITLE: Use anyio.getaddrinfo() for Name Lookups
DESCRIPTION: Switches the library's internal name resolution mechanism to utilize `anyio.getaddrinfo()`. This change aims to provide a more consistent and potentially non-blocking approach to resolving network addresses across different backends.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_222

LANGUAGE: Python
CODE:
```
import anyio

# Example of how anyio.getaddrinfo might be used internally
async def resolve_address(hostname, port):
    addresses = await anyio.getaddrinfo(hostname, port)
    return addresses
```

--------------------------------

TITLE: Iterate Directory Contents Asynchronously with AnyIO Path
DESCRIPTION: Shows how to asynchronously iterate through the contents of a directory using AnyIO's `Path.iterdir()`. It checks if each item is a file and reads its text content asynchronously.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/fileio.rst#_snippet_4

LANGUAGE: Python
CODE:
```
from anyio import Path, run


async def main():
    # Print the contents of every file (assumed to be text) in the directory /foo/bar
    dir_path = Path('/foo/bar')
    async for path in dir_path.iterdir():
        if await path.is_file():
            print(await path.read_text())
            print('---------------------')

run(main)
```

--------------------------------

TITLE: Define an Asynchronous Resource Interface
DESCRIPTION: Defines the interface for objects that can be asynchronously opened and closed. Resources implementing this interface are guaranteed to have an `aclose` method.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_8

LANGUAGE: Python
CODE:
```
class MyAsyncResource(anyio.abc.AsyncResource):
    async def aclose(self):
        pass
```

--------------------------------

TITLE: TLS Stream Wrappers
DESCRIPTION: Provides stream wrappers for handling Transport Layer Security (TLS) connections, enabling secure communication over networks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_61

LANGUAGE: Python
CODE:
```
tls_stream = anyio.streams.tls.TLSStream(wrapped_stream, ssl_context)
tls_listener = anyio.streams.tls.TLSListener(listener, ssl_context)
```

--------------------------------

TITLE: TLSListener Parameters
DESCRIPTION: Adds `handshake_timeout` and `error_handler` parameters to `TLSListener`, allowing for more configuration and error handling during TLS handshake.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_188

LANGUAGE: Python
CODE:
```
anyio.TLSListener(handshake_timeout=..., error_handler=...)
```

--------------------------------

TITLE: Send File Descriptor via UNIX Socket (AnyIO Server)
DESCRIPTION: A server that creates a UNIX socket listener, accepts connections, and sends the file descriptor of an opened file to the client.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_5

LANGUAGE: Python
CODE:
```
from pathlib import Path

from anyio import create_unix_listener, run


async def handle(client):
    async with client:
        with path.open('r') as file:
            await client.send_fds(b'this message is ignored', [file])


async def main():
    listener = await create_unix_listener('/tmp/mysock')
    await listener.serve(handle)

run(main)

path = Path('/tmp/examplefile')
path.write_text('Test file')
run(main)
```

--------------------------------

TITLE: Create UDP Socket
DESCRIPTION: Creates a UDP socket, optionally binding it to a local address. UDP is a connectionless protocol suitable for broadcasting or unreliable data transfer.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_68

LANGUAGE: Python
CODE:
```
udp_socket = await anyio
```

--------------------------------

TITLE: Asyncio StreamWriter Write and Drain
DESCRIPTION: In asyncio, writing data to a stream involves two steps: calling the synchronous write() method to buffer data and then awaiting the drain() coroutine to ensure the data is actually sent. This two-step process is a design limitation addressed by AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_10

LANGUAGE: Python
CODE:
```
writer.write(data)
await writer.drain()
```

--------------------------------

TITLE: Listener Interface
DESCRIPTION: Defines the interface for network listeners, which accept incoming connections. This is the server-side component for network services.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_46

LANGUAGE: Python
CODE:
```
async def accept_connections(listener: anyio.abc.Listener):
    while True:
        client_stream, _ = await listener.accept()
        asyncio.create_task(handle_client(client_stream))
```

--------------------------------

TITLE: AnyIO Host Name Resolution (IDNA 2008)
DESCRIPTION: This snippet explains that for both asyncio and curio backends in AnyIO 2.0.0, host name resolution now uses IDNA 2008 with UTS 46 compatibility mapping, similar to trio, ensuring consistent internationalized domain name handling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_205

LANGUAGE: Python
CODE:
```
Host name resolution now uses `IDNA 2008`_ (with UTS 46 compatibility mapping, just like trio)
```

--------------------------------

TITLE: AnyIO Stream End-of-Stream Handling
DESCRIPTION: Unlike asyncio streams that return empty bytes or None, AnyIO streams raise an EndOfStream exception when no more data is available for reading. This provides a more explicit way to handle the end of a stream.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_9

LANGUAGE: Python
CODE:
```
raise EndOfStream
```

--------------------------------

TITLE: Any Stream Type Aliases
DESCRIPTION: Provides type aliases for various AnyIO stream types, simplifying type hinting and improving code readability.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_48

LANGUAGE: Python
CODE:
```
from typing import Union

StreamType = Union[anyio.abc.ByteStream, anyio.abc.ObjectStream]
```

--------------------------------

TITLE: Implement Timeout with move_on_after in AnyIO
DESCRIPTION: Shows how to use `move_on_after` as a context manager to limit the execution time of a block of code. If the timeout is reached, the context block is exited prematurely, and the `cancelled_caught` attribute of the scope indicates if the timeout occurred.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import create_task_group, move_on_after, sleep, run


async def main():
    async with create_task_group() as tg:
        with move_on_after(1) as scope:
            print('Starting sleep')
            await sleep(2)
            print('This should never be printed')

        # The cancelled_caught property will be True if timeout was reached
        print('Exited cancel scope, cancelled =', scope.cancelled_caught)

run(main)
```

--------------------------------

TITLE: Fix Async Context Manager __aexit__ Call (BlockingPortal)
DESCRIPTION: Corrects an issue where the ``__aexit__()`` method of an async context manager was not being called in ``BlockingPortal.wrap_async_context_manager()`` if the host task was cancelled. This fix was contributed by Jonathan Slenders.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_124

LANGUAGE: Python
CODE:
```
Fixed async context manager's ``__aexit__()`` method not being called in
  ``BlockingPortal.wrap_async_context_manager()`` if the host task is cancelled
  (`#381 <https://github.com/agronholm/anyio/issues/381>`_; PR by Jonathan Slenders)
```

--------------------------------

TITLE: Handle Multiple Exceptions with exceptiongroup.catch in Python
DESCRIPTION: Provides an alternative method for handling multiple exceptions from a task group in Python versions prior to 3.11, using the `catch` function from the `exceptiongroup` library.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_3

LANGUAGE: Python
CODE:
```
from anyio import create_task_group
from exceptiongroup import catch

def handle_valueerror(excgroup: ExceptionGroup) -> None:
    for exc in excgroup.exceptions:
        ...
```

--------------------------------

TITLE: Low-Level Operations
DESCRIPTION: Provides low-level concurrency control mechanisms like checkpoints and cancellation shields. These are useful for fine-grained control over task execution and cancellation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_76

LANGUAGE: Python
CODE:
```
anyio.lowlevel.checkpoint
anyio.lowlevel.checkpoint_if_cancelled
anyio.lowlevel.cancel_shielded_checkpoint
anyio.lowlevel.RunVar
```

--------------------------------

TITLE: Async Fixtures with Higher Scopes (Python)
DESCRIPTION: For asynchronous fixtures with scopes other than 'function', you must define your own `anyio_backend` fixture because the default one is function-scoped.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/testing.rst#_snippet_4

LANGUAGE: python
CODE:
```
@pytest.fixture(scope='module')
```

--------------------------------

TITLE: Fix open_signal_receiver yielding integers on trio
DESCRIPTION: Addresses an inconsistency on the trio backend where open_signal_receiver() sometimes yielded integers instead of signal.Signals instances.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_106

LANGUAGE: Python
CODE:
```
import signal
from anyio import open_signal_receiver

# async def handle_signals():
#     async for sig in open_signal_receiver(signal.SIGINT):
#         # sig should now consistently be a signal.Signals instance
```

--------------------------------

TITLE: File Write Stream
DESCRIPTION: A stream wrapper for writing to files, offering asynchronous write operations and potential buffering.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_53

LANGUAGE: Python
CODE:
```
file_write_stream = anyio.streams.file.FileWriteStream(file_object)
```

--------------------------------

TITLE: Shielded Cleanup in Cancelled Scope
DESCRIPTION: Illustrates how to perform asynchronous cleanup operations within a scope that is already cancelled. This is achieved by wrapping the cleanup code in a shielded CancelScope.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_5

LANGUAGE: Python
CODE:
```
async def do_something():
    try:
        await run_async_stuff()
    except get_cancelled_exc_class():
        with CancelScope(shield=True):
            await some_cleanup_function()

        raise
```

--------------------------------

TITLE: Enable Test Suite Without IPv6 (AnyIO)
DESCRIPTION: Allows the AnyIO test suite to run successfully even when IPv6 support is not available or when using trio or pytest without plugin autoloading.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_127

LANGUAGE: Python
CODE:
```
Enabled the test suite to run without IPv6 support, trio or pytest plugin autoloading
```

--------------------------------

TITLE: Parametrize Pytest Tests with AnyIO Backends
DESCRIPTION: Introduces the capability to parameterize regular pytest test functions against a selected list of AnyIO backends. This allows for more comprehensive testing by running tests with different AnyIO implementations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_223

LANGUAGE: Python
CODE:
```
import pytest
import anyio

@pytest.mark.anyio
@pytest.mark.parametrize("backend", anyio.list_backends())
async def test_feature_with_backends(backend):
    async with anyio.move_on_after(10):
        # Test logic that uses the specified backend
        pass
```

--------------------------------

TITLE: Create a Cancel Scope
DESCRIPTION: Creates a new cancel scope, which is a context manager that allows for structured cancellation of asynchronous operations. Scopes can be nested.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_15

LANGUAGE: Python
CODE:
```
async with anyio.CancelScope() as scope:
    scope.cancel()
    await some_async_code()
```

--------------------------------

TITLE: Add wait_readable/writable support for ProactorEventLoop
DESCRIPTION: Provides support for `wait_readable()` and `wait_writable()` on `ProactorEventLoop`, which is the default on asyncio for Windows.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_30

LANGUAGE: Python
CODE:
```
Added support for ``wait_readable()`` and ``wait_writable()`` on ``ProactorEventLoop``
  (used on asyncio + Windows by default)
```

--------------------------------

TITLE: Configure socket options for selector thread waker
DESCRIPTION: Configures `SO_RCVBUF`, `SO_SNDBUF`, and `TCP_NODELAY` on the selector thread waker socket pair to potentially improve the performance of `wait_readable()` and `wait_writable()` when using `ProactorEventLoop`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_24

LANGUAGE: Python
CODE:
```
Configure ``SO_RCVBUF``, ``SO_SNDBUF`` and ``TCP_NODELAY`` on the selector
  thread waker socket pair (this should improve the performance of ``wait_readable()``
  and ``wait_writable()`` when using the ``ProactorEventLoop``
  (`#836 <https://github.com/agronholm/anyio/pull/836>`_; PR by @graingert)
```

--------------------------------

TITLE: Fix CapacityLimiter token adjustment wake-up on asyncio
DESCRIPTION: Resolves an edge case on the asyncio backend where adjusting the total tokens in a CapacityLimiter failed to wake up waiting tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_71

LANGUAGE: Python
CODE:
```
async def acquire(self, num_tokens: int = 1) -> None:
    """Acquire tokens from the limiter."""
    pass

def set_total_tokens(self, total_tokens: int) -> None:
    """Set the total number of tokens."""
    # ... implementation ensures waiting tasks are woken ...
    pass
```

--------------------------------

TITLE: AnyIO SocketStream API Enhancements
DESCRIPTION: The `SocketStream` API has been extended with `getsockopt()` and `setsockopt()` methods, providing granular control over socket behavior and configuration. This facilitates advanced network programming.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_267

LANGUAGE: Python
CODE:
```
from anyio.streams.stapled import SocketStream

async def configure_socket(stream: SocketStream):
    # Example: Get socket options
    keepalive = await stream.getsockopt(SOL_SOCKET, SO_KEEPALIVE)
    print(f"Keepalive enabled: {keepalive}")

    # Example: Set socket options
    await stream.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
```

--------------------------------

TITLE: AnyIO asyncio Backend Improvements
DESCRIPTION: This snippet details improvements to the AnyIO asyncio backend in version 2.0.0. It includes added support for `ProactorEventLoop` on Windows and the backend now uses `asyncio.run()` for proper shutdown of async generators and cancellation of leftover native tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_202

LANGUAGE: Python
CODE:
```
Added support for `ProactorEventLoop`. This allows asyncio applications to use AnyIO on Windows even without using AnyIO as the entry point.
The asyncio backend now uses `asyncio.run()` behind the scenes which properly shuts down async generators and cancels any leftover native tasks
```

--------------------------------

TITLE: Add Asynchronous Path Class (AnyIO)
DESCRIPTION: Introduces a new asynchronous ``Path`` class to AnyIO, providing asynchronous file system path operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_136

LANGUAGE: Python
CODE:
```
Added asynchronous ``Path`` class
```

--------------------------------

TITLE: Happy Eyeballs Algorithm for connect_tcp()
DESCRIPTION: Implements the Happy Eyeballs algorithm (RFC 6555) for `anyio.connect_tcp()`. This feature improves connection establishment reliability and speed by trying both IPv4 and IPv6 connections concurrently.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_227

LANGUAGE: Python
CODE:
```
import anyio

async def connect_with_happy_eyeballs(host, port):
    # The Happy Eyeballs logic is now integrated into connect_tcp
    async with await anyio.connect_tcp(host, port) as stream:
        pass
```

--------------------------------

TITLE: Fix setsockopt() Option Passing
DESCRIPTION: Corrects the way `setsockopt()` passes options to the underlying method. This ensures that socket options are set correctly, which is crucial for network configuration and behavior.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_262

LANGUAGE: Python
CODE:
```
import anyio
import socket

async def set_socket_options(sock: socket.socket):
    # Example: Setting SO_REUSEADDR
    await sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # The internal handling of this call is now fixed.
```

--------------------------------

TITLE: Wrap a File Object Asynchronously
DESCRIPTION: Wraps a synchronous file object to make it usable within an asynchronous context. This allows existing file handles to be used with AnyIO's async I/O operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_31

LANGUAGE: Python
CODE:
```
sync_file = open('data.bin', 'rb')
async_file = await anyio.wrap_file(sync_file)
```

--------------------------------

TITLE: Stapled Byte Stream
DESCRIPTION: Combines multiple byte streams into a single logical stream, allowing seamless data transfer across different underlying connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_57

LANGUAGE: Python
CODE:
```
stapled_stream = anyio.streams.stapled.StapledByteStream([stream1, stream2])
```

--------------------------------

TITLE: Run One-Shot Command Directly (Python)
DESCRIPTION: Executes an external command directly without involving a shell. This is equivalent to `shell=False` in Python's `subprocess.run`. The command and its arguments are provided as a sequence of strings.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import run_process, run


async def main():
    result = await run_process(['ps'])
    print(result.stdout.decode())

run(main)
```

--------------------------------

TITLE: Improve Lock and Semaphore Performance with fast_acquire
DESCRIPTION: Enhances the performance of anyio.Lock and anyio.Semaphore on asyncio by up to 50%%. Introduces the 'fast_acquire' parameter which boosts performance at the cost of safety, as acquire() will not yield control back if there is no contention.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_47

LANGUAGE: Python
CODE:
```
import anyio

async def use_lock_fast_acquire():
    lock = anyio.Lock()
    # Using fast_acquire for potential performance gains
    async with lock.acquire_with_flags(anyio.LockFlags.NO_WAIT):
        print("Lock acquired immediately.")

async def use_semaphore_fast_acquire():
    semaphore = anyio.Semaphore(1)
    # Using fast_acquire for potential performance gains
    async with semaphore.acquire_with_flags(anyio.SemaphoreFlags.NO_WAIT):
        print("Semaphore acquired immediately.")
```

--------------------------------

TITLE: Provide Typed Attributes
DESCRIPTION: An interface for objects that can provide a set of typed attributes. This allows other objects to access metadata in a structured way.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_11

LANGUAGE: Python
CODE:
```
class MyProvider(anyio.TypedAttributeProvider):
    def typed_attributes(self):
        return anyio.TypedAttributeSet()
```

--------------------------------

TITLE: AsyncFile Generics Update
DESCRIPTION: Updates the generics in ``AsyncFile`` to ensure methods correctly return ``str`` or ``bytes`` based on the argument provided to ``open_file()``.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_140

LANGUAGE: Python
CODE:
```
Changed the generics in ``AsyncFile`` so that the methods correctly return either
  ``str`` or ``bytes`` based on the argument to ``open_file()``
```

--------------------------------

TITLE: Add support for byte-based paths in Unix socket functions
DESCRIPTION: Enables the use of byte-based paths for various Unix socket operations, including connecting, creating listeners, and creating datagram sockets.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_67

LANGUAGE: Python
CODE:
```
async def connect_unix(path: bytes, ...) -> None:
    """Connect to a Unix socket."""
    pass

def create_unix_listeners(path: bytes, ...) -> None:
    """Create Unix domain socket listeners."""
    pass

def create_unix_datagram_socket(path: bytes, ...) -> None:
    """Create a Unix domain datagram socket."""
    pass

def create_connected_unix_datagram_socket(path: bytes, ...) -> None:
    """Create a connected Unix domain datagram socket."""
    pass
```

--------------------------------

TITLE: Suppress DeprecationWarning for TaskGroup.spawn in AnyIO 3
DESCRIPTION: Illustrates how to suppress `DeprecationWarning` when using `TaskGroup.spawn()` in AnyIO 3 for code that needs to maintain compatibility with AnyIO 2. This is a temporary measure until AnyIO 4.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_8

LANGUAGE: Python
CODE:
```
import warnings
from anyio import create_task_group

async def foo():
    async with create_task_group() as tg:
        with warnings.catch_warnings():
            await tg.spawn(otherfunc)
```

--------------------------------

TITLE: Asynchronous File Interface
DESCRIPTION: Defines the interface for asynchronous file objects, providing methods for reading, writing, and seeking without blocking the event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_32

LANGUAGE: Python
CODE:
```
async def read_file_content(file: anyio.AsyncFile):
    content = await file.read()
    return content
```

--------------------------------

TITLE: Create Memory Object Stream
DESCRIPTION: Creates a pair of connected asynchronous streams that transfer arbitrary Python objects in memory. Useful for inter-task communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_42

LANGUAGE: Python
CODE:
```
send_stream, receive_stream = anyio.create_memory_object_stream()
```

--------------------------------

TITLE: Provide Values for Custom Typed Attributes
DESCRIPTION: Illustrates how to provide values for custom typed attributes by implementing the `extra_attributes` property in a class inheriting from `TypedAttributeProvider`. This property returns a mapping of attributes to their provider functions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from collections.abc import Callable, Mapping

from anyio import TypedAttributeProvider


class MyAttributeProvider(TypedAttributeProvider):
    @property
    def extra_attributes() -> Mapping[Any, Callable[[], Any]]:
        return {
            MyTypedAttribute.string_valued_attribute: lambda: 'my attribute value',
            MyTypedAttribute.some_float_attribute: lambda: 6.492
        }
```

--------------------------------

TITLE: Add experimental subinterpreter support
DESCRIPTION: Introduces experimental support for running functions within subinterpreters, available on Python 3.13 and later.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_22

LANGUAGE: Python
CODE:
```
Added **experimental** support for running functions in subinterpreters on Python
  3.13 and later
```

--------------------------------

TITLE: Connectable Objects
DESCRIPTION: Represents objects that can be connected to, such as TCP or UNIX domain sockets. These are used to establish network connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_72

LANGUAGE: Python
CODE:
```
anyio.TCPConnectable
anyio.UNIXConnectable
```

--------------------------------

TITLE: Stapled Object Stream
DESCRIPTION: Combines multiple object streams into a single logical stream for unified object transfer.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_58

LANGUAGE: Python
CODE:
```
stapled_stream = anyio.streams.stapled.StapledObjectStream([obj_stream1, obj_stream2])
```

--------------------------------

TITLE: Resolve Host Names with anyio.getaddrinfo()
DESCRIPTION: Ensures that host names are resolved using `anyio.getaddrinfo()` before calling `socket.sendto()` to prevent blocking on synchronous name resolution. This improves network operation by avoiding blocking calls.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_221

LANGUAGE: Python
CODE:
```
import anyio

# Example usage within a function that sends data via UDP
async def send_udp_data(socket, data, address):
    await socket.sendto(data, address)

# The fix ensures that anyio.getaddrinfo() is used internally by UDPSocket.send()
```

--------------------------------

TITLE: Fix return annotation of __aexit__
DESCRIPTION: Corrects the return annotation for `__aexit__` in async context managers. It clarifies that the method should return `bool` if it suppresses an exception, and `None` otherwise.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_6

LANGUAGE: Python
CODE:
```
import anyio
from typing import Optional, Type, Any

class MyContextManager:
    async def __aenter__(self) -> Any:
        return self

    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[Any]) -> Optional[bool]:
        if exc_type is not None:
            # Decide whether to suppress the exception
            return True # Suppress exception
        return None # Do not suppress exception

```

--------------------------------

TITLE: Add ExceptionGroup.exceptions Documentation
DESCRIPTION: Includes the missing documentation for the ``exceptions`` attribute of the ``ExceptionGroup`` class.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_132

LANGUAGE: Python
CODE:
```
Added missing documentation for the ``ExceptionGroup.exceptions`` attribute
```

--------------------------------

TITLE: Correct API Documentation in AnyIO
DESCRIPTION: Version 1.4.0 corrects the API documentation for Stream.receive_until(), clarifying that the delimiter is not included in the returned data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_220

LANGUAGE: Python
CODE:
```
Fixed API documentation on Stream.receive_until() which claimed that the delimiter will be included in the returned data when it really isn't
```

--------------------------------

TITLE: Task Group Interface
DESCRIPTION: Defines the interface for task groups, which are used to manage concurrent tasks. It includes methods for spawning tasks and waiting for their completion.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_17

LANGUAGE: Python
CODE:
```
async def run_tasks(tg: anyio.abc.TaskGroup):
    await tg.spawn(task1)
    await tg.spawn(task2, arg1)
```

--------------------------------

TITLE: Fix anyio.AsyncFile readinto annotations
DESCRIPTION: Corrects the return type annotations for the `readinto()` and `readinto1()` methods within the `anyio.AsyncFile` class.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_32

LANGUAGE: Python
CODE:
```
Fixed the return type annotations of ``readinto()`` and ``readinto1()`` methods in the
  ``anyio.AsyncFile`` class
  (`#825 <https://github.com/agronholm/anyio/issues/825>`_)
```

--------------------------------

TITLE: Spawn Task from Worker Thread using BlockingPortal (AnyIO)
DESCRIPTION: Illustrates spawning background tasks from a worker thread using `BlockingPortal.start_task_soon`. This method returns a `concurrent.futures.Future` that can be used to track the task's completion and retrieve its result. Tasks can be cancelled by cancelling the returned future.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_5

LANGUAGE: Python
CODE:
```
from concurrent.futures import as_completed

from anyio import sleep
from anyio.from_thread import start_blocking_portal


async def long_running_task(index):
    await sleep(1)
    print(f'Task {index} running...')
    await sleep(index)
    return f'Task {index} return value'


with start_blocking_portal() as portal:
    futures = [portal.start_task_soon(long_running_task, i) for i in range(1, 5)]
    for future in as_completed(futures):
        print(future.result())
```

--------------------------------

TITLE: Add UNIX Datagram Socket Creation Functions
DESCRIPTION: Introduces `create_unix_datagram_socket` and `create_connected_unix_datagram_socket` functions for creating UNIX domain datagram sockets, contributed by Jean Hominal.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_86

LANGUAGE: python
CODE:
```
Added ``create_unix_datagram_socket`` and ``create_connected_unix_datagram_socket`` to
  create UNIX datagram sockets (PR by Jean Hominal)
```

--------------------------------

TITLE: Shield Task from Cancellation in AnyIO
DESCRIPTION: Demonstrates how to shield a task from cancellation by creating a cancel scope with `shield=True`. This is useful for critical operations like resource cleanup, ensuring they complete even if the parent scope is cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from anyio import CancelScope, create_task_group, sleep, run


async def external_task():
    print('Started sleeping in the external task')
    await sleep(1)
    print('This line should never be seen')


async def main():
    async with create_task_group() as tg:
        with CancelScope(shield=True):
            tg.start_soon(external_task)
            await sleep(0.5) # Give external_task time to start
            tg.cancel_scope.cancel() # Cancel the main task group

    print('Task group finished')

run(main)
```

--------------------------------

TITLE: Fix Process aclose cleanup on cancellation
DESCRIPTION: Addresses issues where cancelling Process.aclose() or run_process() could lead to orphaned processes or unclosed standard streams, particularly on the Trio backend. Ensures necessary cleanup is performed.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_65

LANGUAGE: Python
CODE:
```
def aclose(self) -> None:
    """Cleanly shut down the process."""
    # ... implementation details ...
    pass
```

--------------------------------

TITLE: Add wait_readable and wait_writable functions
DESCRIPTION: Introduces `wait_readable()` and `wait_writable()` functions that accept file descriptors or objects with a `.fileno()` method, deprecating the older `wait_socket_readable()` and `wait_socket_writable()`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_28

LANGUAGE: Python
CODE:
```
Added the ``wait_readable()`` and ``wait_writable()`` functions which will accept
  an object with a ``.fileno()`` method or an integer handle, and deprecated
  their now obsolete versions (``wait_socket_readable()`` and
  ``wait_socket_writable()``) (PR by @davidbrochart)
```

--------------------------------

TITLE: Testing Task Groups with Specific Exceptions (pytest)
DESCRIPTION: Illustrates how to adapt pytest tests that previously expected a specific exception from a task group in AnyIO 3. In AnyIO 4, task groups raise ExceptionGroups, so tests must now expect `ExceptionGroup` and then inspect its contents to verify the original exception type.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/migration.rst#_snippet_2

LANGUAGE: Python
CODE:
```
from exceptiongroup import ExceptionGroup

with pytest.raises(ExceptionGroup) as exc:
    await function_using_a_taskgroup()

assert len(exc.value.exceptions) == 1
assert isinstance(exc.value.exceptions[0], ValueError)
```

--------------------------------

TITLE: Create UNIX Listener
DESCRIPTION: Modifies `create_unix_listener()` to remove existing sockets at the specified path before creating a new listener. This prevents `OSError: Address already in use` exceptions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_162

LANGUAGE: Python
CODE:
```
anyio.create_unix_listener()
```

--------------------------------

TITLE: Buffered Byte Stream
DESCRIPTION: A byte stream that provides buffering for both sending and receiving operations, optimizing I/O efficiency.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_50

LANGUAGE: Python
CODE:
```
buffered_stream = anyio.streams.buffered.BufferedByteStream(underlying_stream)
```

--------------------------------

TITLE: Adapt Trio API changes for to_thread.run_sync
DESCRIPTION: Updates the `anyio.to_thread.run_sync` function to use the `abandon_on_cancel` keyword argument instead of `cancellable`, aligning with API changes in Trio v0.23.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_72

LANGUAGE: Python
CODE:
```
async def run_sync(func: Callable[..., T], *args: Any, abandon_on_cancel: bool = False, **kwargs: Any) -> T:
    """Run a synchronous function in a thread."""
    pass
```

--------------------------------

TITLE: Add sleep_forever() and sleep_until() Functions
DESCRIPTION: Introduces the ``sleep_forever()`` and ``sleep_until()`` functions for managing asynchronous sleep operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_153

LANGUAGE: Python
CODE:
```
Added the ``sleep_forever()`` and ``sleep_until()`` functions
```

--------------------------------

TITLE: RunVar Class for Event Loop Scoping
DESCRIPTION: Introduces the `RunVar` class for scoping variables to the running event loop. This provides a mechanism for managing state specific to an event loop instance.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_179

LANGUAGE: Python
CODE:
```
anyio.RunVar
```

--------------------------------

TITLE: Blocking Portal Interface
DESCRIPTION: Represents a portal for communication between synchronous threads and the AnyIO event loop. It allows threads to run asynchronous code and receive results.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_29

LANGUAGE: Python
CODE:
```
portal = anyio.from_thread.BlockingPortal()
portal.run_sync_soon(async_task)
result = portal.call_soon(sync_func)
```

--------------------------------

TITLE: Run Sync Code in Process
DESCRIPTION: Introduces the `run_sync_in_process()` function for executing synchronous code within separate worker processes. This is useful for offloading blocking operations from the main asynchronous event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_159

LANGUAGE: Python
CODE:
```
anyio.run_sync_in_process()
```

--------------------------------

TITLE: Fix anyio.to_thread.run_sync() reference holding
DESCRIPTION: Eliminates the unnecessary holding of references to context, function, arguments, and other items by `anyio.to_thread.run_sync()` on asyncio until the next work item.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_21

LANGUAGE: Python
CODE:
```
Fixed ``anyio.to_thread.run_sync()`` needlessly holding on to references of the
  context, function, arguments and others until the next work item on asyncio
  (PR by @Wankupi)
```

--------------------------------

TITLE: Manage Typed Attributes
DESCRIPTION: Provides a set of typed attributes that can be associated with an object. This allows for organized and type-safe storage of metadata.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_10

LANGUAGE: Python
CODE:
```
typed_attrs = anyio.TypedAttributeSet()
typed_attrs.update({'key': 'value'})
value = typed_attrs.get('key')
```

--------------------------------

TITLE: Synchronization Primitive Statistics
DESCRIPTION: Introduces the `statistics()` method for various synchronization primitives, including `Event`, `Lock`, `Condition`, `Semaphore`, `CapacityLimiter`, `MemoryObjectReceiveStream`, and `MemoryObjectSendStream`. This method provides insights into the internal state of these primitives.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_168

LANGUAGE: Python
CODE:
```
anyio.Event.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.Lock.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.Condition.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.Semaphore.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.CapacityLimiter.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.MemoryObjectReceiveStream.statistics()
```

LANGUAGE: Python
CODE:
```
anyio.MemoryObjectSendStream.statistics()
```

--------------------------------

TITLE: Add Async Name Resolution in AnyIO
DESCRIPTION: Version 1.4.0 of AnyIO introduces asynchronous name resolution functions, getaddrinfo() and getnameinfo(), for network address translation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_216

LANGUAGE: Python
CODE:
```
Added async name resolution functions (anyio.getaddrinfo() and anyio.getnameinfo())
```

--------------------------------

TITLE: Text Stream Interface
DESCRIPTION: Defines the interface for streams that handle text data, abstracting away the underlying byte encoding and decoding.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_60

LANGUAGE: Python
CODE:
```
async def send_text(stream: anyio.streams.text.TextSendStream, text: str):
    await stream.send_text(text)
```

--------------------------------

TITLE: Relax Path Initializer Type (FileReadStream/FileWriteStream)
DESCRIPTION: The type for the ``path`` initializer argument in ``FileReadStream`` and ``FileWriteStream`` has been relaxed to accept any path-like object, including the new asynchronous ``Path`` class.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_138

LANGUAGE: Python
CODE:
```
Relaxed the type of the ``path`` initializer argument to ``FileReadStream`` and
  ``FileWriteStream`` so they accept any path-like object (including the new
  asynchronous ``Path`` class)
```

--------------------------------

TITLE: Asyncio Test Runner Default (No uvloop)
DESCRIPTION: Configures the asyncio test runner to not use uvloop by default, aligning its behavior with ``anyio.run()``.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_133

LANGUAGE: Python
CODE:
```
Changed the asyncio test runner not to use uvloop by default (to match the behavior of
  ``anyio.run()``)
```

--------------------------------

TITLE: AnyIO Exceptions
DESCRIPTION: Defines a set of custom exceptions used throughout the AnyIO library to indicate various error conditions, such as broken resources, busy resources, connection failures, and incomplete reads.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_78

LANGUAGE: Python
CODE:
```
anyio.BrokenResourceError
anyio.BrokenWorkerInterpreter
anyio.BrokenWorkerProcess
anyio.BusyResourceError
anyio.ClosedResourceError
anyio.ConnectionFailed
anyio.DelimiterNotFound
anyio.EndOfStream
anyio.IncompleteRead
anyio.TypedAttributeLookupError
anyio.WouldBlock
```

--------------------------------

TITLE: Asyncio Shielding: Orphaned Tasks and Unpropagated Exceptions
DESCRIPTION: Illustrates the issue with asyncio.shield where a shielded task can become orphaned if the host task is cancelled. This can lead to exceptions not propagating and tasks being garbage collected mid-execution.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_3

LANGUAGE: Python
CODE:
```
import asyncio
import gc


async def shielded_task():
    fut = asyncio.get_running_loop().create_future()
    await fut


async def host_task():
    await asyncio.shield(shielded_task())


async def main():
    async with asyncio.TaskGroup() as tg:
        task = tg.create_task(host_task())
        await asyncio.sleep(0)  # allow the host task to start
        task.cancel()
        await asyncio.sleep(0)  # allow the cancellation to take effect on the host task
        gc.collect()

# Prints warning: Task was destroyed but it is pending!
asyncio.run(main())
```

--------------------------------

TITLE: Pin Trio to avoid ExceptionGroup incompatibility
DESCRIPTION: Pins the Trio dependency to versions less than 0.22 to prevent an AttributeError ('NonBaseMultiError' object has no attribute '_exceptions') caused by incompatibility with AnyIO's ExceptionGroup class.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_114

LANGUAGE: Python
CODE:
```
# requirements.txt or setup.py:
# anyio<3.7.0
# trio<0.22
```

--------------------------------

TITLE: Maybe Async Functions
DESCRIPTION: Adds `maybe_async()` and `maybe_async_cm()` functions to facilitate forward compatibility with AnyIO 3. These functions allow writing code that can seamlessly work with both synchronous and asynchronous contexts.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_180

LANGUAGE: Python
CODE:
```
anyio.maybe_async()
```

LANGUAGE: Python
CODE:
```
anyio.maybe_async_cm()
```

--------------------------------

TITLE: Improvement: Running Synchronous Code from Threads
DESCRIPTION: Introduces the `run_sync_from_thread()` function to improve the process of running synchronous code, likely from within a different thread context.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_158

LANGUAGE: Python
CODE:
```
import anyio

def sync_function():
    print("Running synchronous function")

async def main():
    # Example of running a synchronous function from a thread
    await anyio.to_thread.run_sync(sync_function)

# anyio.run(main)
```

--------------------------------

TITLE: Fix anyio.Path.copy() and copy_into() on Python 3.14.0a7
DESCRIPTION: Corrects an issue where `anyio.Path.copy()` and `anyio.Path.copy_into()` failed on specific pre-release versions of Python 3.14. This ensures reliable file copying operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_5

LANGUAGE: Python
CODE:
```
import anyio

# Example usage (assuming the fix is applied):
# async def copy_file():
#     source_path = anyio.Path('source.txt')
#     dest_path = anyio.Path('destination.txt')
#     await source_path.copy(dest_path)

#     dest_dir = anyio.Path('dest_dir')
#     await source_path.copy_into(dest_dir)

```

--------------------------------

TITLE: AnyIO Memory Object Stream Statistics
DESCRIPTION: The MemoryObjectReceiveStream in AnyIO provides a statistics method to gather information about the stream's state, including queued items, open streams, and waiting tasks. This aids in debugging and understanding stream behavior.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_8

LANGUAGE: Python
CODE:
```
stream.statistics()
```

--------------------------------

TITLE: Run Synchronous Function in a Subinterpreter
DESCRIPTION: Executes a synchronous function within a separate Python subinterpreter. This provides process-like isolation without the overhead of full processes, useful for running untrusted code.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_21

LANGUAGE: Python
CODE:
```
result = await anyio.to_interpreter.run_sync(sync_function, arg1, interpreter=my_interpreter)
```

--------------------------------

TITLE: Add info property to anyio.Path on Python 3.14
DESCRIPTION: Introduces an `info` property to `anyio.Path` objects when running on Python 3.14. This property provides detailed file status information, similar to `os.stat()`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_16

LANGUAGE: Python
CODE:
```
import anyio

# async def get_file_info():
#     path = anyio.Path('my_file.txt')
#     if hasattr(path, 'info'): # Check for Python 3.14+
#         file_info = await path.info()
#         print(f"File size: {file_info.st_size}")

```

--------------------------------

TITLE: Specify thread name in start_blocking_portal
DESCRIPTION: Allows specifying a custom thread name when using `start_blocking_portal()`. This helps in identifying and debugging threads created by AnyIO when running blocking code in a separate thread.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_3

LANGUAGE: Python
CODE:
```
import anyio

async def main():
    def blocking_function():
        pass
    await anyio.to_thread.start_blocking_portal(blocking_function, name='my-custom-thread')

# anyio.run(main)

```

--------------------------------

TITLE: Byte Stream Interfaces
DESCRIPTION: Defines interfaces for streams that transfer raw bytes. These are fundamental for network communication and file I/O.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_45

LANGUAGE: Python
CODE:
```
async def read_bytes(stream: anyio.abc.ByteReceiveStream, nbytes: int):
    return await stream.receive_bytes(nbytes)
```

--------------------------------

TITLE: Cancel Task Group in AnyIO
DESCRIPTION: Demonstrates how to cancel all tasks within a task group by cancelling its associated cancel scope. Tasks waiting on operations will be cancelled immediately, while others will be cancelled at their next yield point.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/cancellation.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio import create_task_group, get_cancelled_exc_class, sleep, run


async def waiter(index: int):
    try:
        await sleep(1)
    except get_cancelled_exc_class():
        print(f"Waiter {index} cancelled")
        raise


async def taskfunc():
    async with create_task_group() as tg:
        # Start a couple tasks and wait until they are blocked
        tg.start_soon(waiter, 1)
        tg.start_soon(waiter, 2)
        await sleep(0.1)

        # Cancel the scope and exit the task group
        tg.cancel_scope.cancel()

run(taskfunc)
```

--------------------------------

TITLE: Fix Pathlib2 Compatibility with aopen()
DESCRIPTION: Ensures compatibility with the `pathlib2` library when using `anyio.aopen()`. This allows asynchronous file operations to work correctly with `pathlib2` objects.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_254

LANGUAGE: Python
CODE:
```
import anyio
from pathlib2 import Path

async def async_open_pathlib2():
    path = Path("my_file.txt")
    async with await anyio.aopen(path) as f:
        await f.write("hello")
```

--------------------------------

TITLE: Fix ResourceWarning on UNIX Socket Connect Fail (Asyncio)
DESCRIPTION: Addresses a ``ResourceWarning`` concerning an unclosed socket that occurred when a UNIX socket connection failed in asyncio.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_148

LANGUAGE: Python
CODE:
```
Fixed ``ResourceWarning`` about an unclosed socket when UNIX socket connect fails on
  asyncio
```

--------------------------------

TITLE: Update UDPSocket Methods in AnyIO
DESCRIPTION: This section describes the modifications to the UDPSocket class in AnyIO, including changes to its attributes, method signatures, and parameter requirements for sending data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_209

LANGUAGE: Python
CODE:
```
address → .extra(SocketAttribute.local_address)
getsockopt() → .extra(SocketAttribute.raw_socket).getsockopt(...)
port → .extra(SocketAttribute.local_port)
receive() no longer takes a maximum bytes argument
receive_packets() → (removed; use async for on the UDP socket instead)
send() → requires a tuple for destination now (address, port), for compatibility with the new UnreliableObjectStream interface. The sendto() method works like the old send() method.
setsockopt() → .extra(SocketAttribute.raw_socket).setsockopt(...)
```

--------------------------------

TITLE: Fix connect_tcp() cyclic references in tracebacks
DESCRIPTION: Corrects an issue where `connect_tcp()` could produce cyclic references in tracebacks when exceptions were raised.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_20

LANGUAGE: Python
CODE:
```
Fixed ``connect_tcp()`` producing cyclic references in tracebacks when raising
  exceptions (`#809 <https://github.com/agronholm/anyio/pull/809>`_; PR by @graingert)
```

--------------------------------

TITLE: Fix OSError with IPv6 link-local addresses in create_tcp_listener
DESCRIPTION: Resolves an OSError when using create_tcp_listener() to bind to a link-local IPv6 address. Includes workarounds for related bugs in uvloop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_112

LANGUAGE: Python
CODE:
```
from anyio import create_tcp_listener

# Example usage:
# listener = create_tcp_listener(local_address=('fe80::1%eth0', 80))
# The fix ensures this operation succeeds without errors.
```

--------------------------------

TITLE: File Read Stream
DESCRIPTION: A stream wrapper specifically for reading from files, potentially with added buffering or other optimizations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_52

LANGUAGE: Python
CODE:
```
file_read_stream = anyio.streams.file.FileReadStream(file_object)
```

--------------------------------

TITLE: Fix UDPSocket.send() Address Parameter Type
DESCRIPTION: Corrects the type hint for the `address` parameter in `UDPSocket.send()` to include `IPAddress` objects. While the underlying implementation already supported these, the type hint was updated for better accuracy and clarity.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_238

LANGUAGE: Python
CODE:
```
from anyio.abc import UDPSocket
from anyio.socket import IPAddress

async def send_with_ipaddress(socket: UDPSocket, data: bytes, address: IPAddress):
    await socket.sendto(data, address)
```

--------------------------------

TITLE: Writable CancelScope Deadline
DESCRIPTION: Makes the `CancelScope.deadline` attribute writable, allowing dynamic adjustment of cancellation deadlines for tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_165

LANGUAGE: Python
CODE:
```
anyio.CancelScope.deadline
```

--------------------------------

TITLE: Async Iteration for Queues
DESCRIPTION: Enables asynchronous iteration for queues within AnyIO. This feature simplifies the process of consuming items from queues in an asynchronous manner, making queue processing more straightforward.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_230

LANGUAGE: Python
CODE:
```
import anyio

async def consume_from_queue(queue: anyio.Queue):
    async for item in queue:
        print(f"Received: {item}")
```

--------------------------------

TITLE: Fix context manager __exit__ return type annotations
DESCRIPTION: Corrects the return type annotations for the `__exit__` method of various context managers.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_26

LANGUAGE: Python
CODE:
```
Fixed return type annotation of various context managers' ``__exit__`` method
  (`#847 <https://github.com/agronholm/anyio/issues/847>`_; PR by @Enegg)
```

--------------------------------

TITLE: Fix regression with parametrized async fixtures
DESCRIPTION: Addresses a regression that prevented the use of parametrized async fixtures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_35

LANGUAGE: Python
CODE:
```
Fixed regression caused by (`#807 <https://github.com/agronholm/anyio/pull/807>`_)
  that prevented the use of parametrized async fixtures
```

--------------------------------

TITLE: Fix TLSListener handshake error logging in asyncio
DESCRIPTION: Addresses a CPython bug where TLSListener.handle_handshake_error() on asyncio logged 'NoneType: None' instead of the actual error message.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_98

LANGUAGE: Python
CODE:
```
def handle_handshake_error():
    # Original code might have logged a generic message
    # This fix ensures the specific error is logged
    pass
```

--------------------------------

TITLE: Spooled Temporary File
DESCRIPTION: A temporary file that behaves like an in-memory file until a certain size is reached, at which point it is written to disk. This optimizes for small temporary data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_38

LANGUAGE: Python
CODE:
```
async with await anyio.SpooledTemporaryFile(max_size=1024) as spooled_file:
    await spooled_file.write(b'small data')
```

--------------------------------

TITLE: Pytest Plugin Changes in AnyIO
DESCRIPTION: This outlines modifications to the AnyIO pytest plugin, including the removal of a command-line option, refactoring for better async fixture utilization, and fixing Hypothesis support.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_215

LANGUAGE: Python
CODE:
```
Removed the --anyio-backends command line option for the pytest plugin. Use the -k option to do ad-hoc filtering, and the anyio_backend fixture to control which backends you wish to run the tests by default.
The pytest plugin was refactored to run the test and all its related async fixtures inside the same event loop, making async fixtures much more useful
Fixed Hypothesis support in the pytest plugin
```

--------------------------------

TITLE: Define Custom Typed Attributes
DESCRIPTION: Shows how to define custom typed attributes using `TypedAttributeSet` and `typed_attribute`. This involves creating a class that inherits from `TypedAttributeSet` and defining attributes with their types.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import TypedAttributeSet, typed_attribute


class MyTypedAttribute(TypedAttributeSet):
    string_valued_attribute: str = typed_attribute()
    some_float_attribute: float = typed_attribute()
```

--------------------------------

TITLE: Asyncio Shielding and Event Loop Shutdown Cancellation
DESCRIPTION: Demonstrates how asyncio.shield does not protect tasks from cancellation when the event loop is shut down, such as during a simulated SIGINT (Ctrl+C).

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_4

LANGUAGE: Python
CODE:
```
import asyncio
import signal


async def finalizer():
    await asyncio.sleep(1)
    print("Finalizer done")

async def main():
    ...  # the business logic goes here
    asyncio.get_running_loop().call_soon(signal.raise_signal, signal.SIGINT)  # simulate ctrl+C
    await asyncio.shield(finalizer())

# Prints a traceback containing a KeyboardInterrupt and a CancelledError, but not the "Finalizer done" message
asyncio.run(main())
```

--------------------------------

TITLE: File Stream Attributes
DESCRIPTION: Provides attributes related to file streams, such as file descriptor or mode. Useful for inspecting or configuring file-based I/O.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_51

LANGUAGE: Python
CODE:
```
attrs = anyio.streams.file.FileStreamAttribute(file_descriptor=1, mode='r')
```

--------------------------------

TITLE: AnyIO BaseSocket sendall() Fix
DESCRIPTION: Addresses an issue in `BaseSocket.sendall()` where large buffers were mishandled. This fix ensures reliable transmission of large data chunks, improving performance and data integrity.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_268

LANGUAGE: Python
CODE:
```
from anyio.abc import SocketStream

async def send_large_data(socket: SocketStream, data: bytes):
    await socket.sendall(data)
    # The fix ensures this handles large data efficiently.
```

--------------------------------

TITLE: Context Propagation to Worker Threads (to_thread.run_sync)
DESCRIPTION: Enhances context propagation to and from worker threads for functions like ``to_thread.run_sync()``, ``from_thread.run()``, and ``from_thread.run_sync()``. Requires Python 3.7 for proper functionality with asyncio.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_122

LANGUAGE: Python
CODE:
```
Added context propagation to/from worker threads in ``to_thread.run_sync()``,
  ``from_thread.run()`` and ``from_thread.run_sync()``
  (`#363 <https://github.com/agronholm/anyio/issues/363>`_; partially based on a PR by
  Sebastián Ramírez)

  **NOTE**: Requires Python 3.7 to work properly on asyncio!
```

--------------------------------

TITLE: Update anyio.Path Documentation and is_junction Availability
DESCRIPTION: Corrects documentation for anyio.Path regarding method limitations based on Python version and makes 'is_junction' unavailable on Python versions earlier than 3.12.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_46

LANGUAGE: Python
CODE:
```
import anyio
import sys

async def check_path_junction(path_str):
    p = anyio.Path(path_str)
    if sys.version_info >= (3, 12):
        if await p.is_junction():
            print(f"{path_str} is a junction.")
    else:
        print("is_junction() is not available on this Python version.")

# Example usage:
# await check_path_junction("/path/to/some/directory")
```

--------------------------------

TITLE: Add __slots__ to AsyncResource
DESCRIPTION: Appends '__slots__' to 'AsyncResource', enabling child classes to utilize '__slots__' for memory optimization.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_60

LANGUAGE: Python
CODE:
```
import anyio

# This change is internal to AnyIO's AsyncResource class.
# The benefit is for developers subclassing AsyncResource.

class MyAsyncResource(anyio.resources.AsyncResource):
    __slots__ = ('my_attribute',)

    def __init__(self, my_attribute):
        self.my_attribute = my_attribute

    async def __aenter__(self):
        print(f"Entering resource with {self.my_attribute}")
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Exiting resource")

# Example usage:
# async def main():
#     async with MyAsyncResource("value") as resource:
#         print(f"Inside resource: {resource.my_attribute}")
#
# anyio.run(main)
```

--------------------------------

TITLE: Run Coroutine Function from Worker Thread (AnyIO)
DESCRIPTION: Allows calling a coroutine function in the event loop thread from an AnyIO worker thread. This is a direct counterpart to asyncio's run_coroutine_threadsafe.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_14

LANGUAGE: Python
CODE:
```
anyio.from_thread.run(func, *args, backend=None, backend_options=None)
```

--------------------------------

TITLE: Update Pytest Plugin for Task Group Execution (AnyIO 4.0.0)
DESCRIPTION: The AnyIO pytest plugin was updated in version 4.0.0 to run all tests and fixtures within the same task group. This allows fixtures to effectively set context variables for tests and other fixtures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_78

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** Changes the pytest plugin to run all tests and fixtures in
  the same task, allowing fixtures to set context variables for tests and other fixtures
```

--------------------------------

TITLE: Fix wait_all_tasks_blocked() with Generator Tasks
DESCRIPTION: Corrects the behavior of `wait_all_tasks_blocked()` when used with generator-based tasks in the asyncio backend. It now functions as expected, ensuring accurate task state monitoring.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_241

LANGUAGE: Python
CODE:
```
import anyio

async def my_generator_task():
    yield

async def check_blocked_tasks():
    async with anyio.create_task_group() as tg:
        await tg.spawn(my_generator_task)
        # wait_all_tasks_blocked() should now work correctly
```

--------------------------------

TITLE: Fix TaskInfo.has_pending_cancellation() false positives
DESCRIPTION: Resolves instances where `TaskInfo.has_pending_cancellation()` on asyncio might return false positives during cleanup code on Python versions 3.11 and later.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_33

LANGUAGE: Python
CODE:
```
Fixed ``TaskInfo.has_pending_cancellation()`` on asyncio returning false positives in
  cleanup code on Python >= 3.11
  (`#832 <https://github.com/agronholm/anyio/issues/832>`_; PR by @gschaffner)
```

--------------------------------

TITLE: Fix to_thread.run_sync() Hanging on Second Call (Asyncio)
DESCRIPTION: Corrects an issue where ``to_thread.run_sync()`` would hang on its second call within asyncio when used with ``loop.run_until_complete()``.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_146

LANGUAGE: Python
CODE:
```
Fixed ``to_thread.run_sync()`` hanging on the second call on asyncio when used with
  ``loop.run_until_complete()``
```

--------------------------------

TITLE: Task Synchronization Changes in AnyIO
DESCRIPTION: This covers significant changes in AnyIO's task synchronization primitives, including the replacement of queues, addition of acquire/release methods, and removal of Event.clear().

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_214

LANGUAGE: Python
CODE:
```
Queues were replaced by memory object streams
Added the acquire() and release() methods to the Lock, Condition and Semaphore classes
Removed the Event.clear() method. You must now replace the event object with a new one rather than clear the old one.
Fixed Condition.wait() not working on asyncio and curio
```

--------------------------------

TITLE: Fix Type Annotation for open_signal_receiver
DESCRIPTION: Corrects the type annotation for ``open_signal_receiver()``, ensuring it accurately reflects its role as a synchronous context manager.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_149

LANGUAGE: Python
CODE:
```
Fixed the type annotation of ``open_signal_receiver()`` as a synchronous context
  manager
```

--------------------------------

TITLE: Workaround for OpenSSL 3.0 Compatibility (bpo-46313)
DESCRIPTION: Introduces a workaround to ensure compatibility with OpenSSL version 3.0, addressing a specific issue tracked as bpo-46313.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_121

LANGUAGE: Python
CODE:
```
Added workaround for bpo-46313_ to enable compatibility with OpenSSL 3.0

.. _bpo-46313: https://bugs.python.org/issue46313
```

--------------------------------

TITLE: Convert Task Names to str Early (Asyncio)
DESCRIPTION: Optimizes task naming in asyncio by converting task names to strings earlier in the process. This change was contributed by Thomas Grainger.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_155

LANGUAGE: Python
CODE:
```
Changed task names to be converted to ``str`` early on asyncio (PR by Thomas Grainger)
```

--------------------------------

TITLE: Add lock Parameter to create_condition()
DESCRIPTION: Introduces the `lock` parameter to `anyio.create_condition()`. This allows users to provide their own lock object to be used with the condition variable, offering greater flexibility in synchronization patterns.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_251

LANGUAGE: Python
CODE:
```
import anyio

async def custom_condition():
    my_lock = anyio.Lock()
    condition = anyio.create_condition(lock=my_lock)
    # Use the condition variable with the provided lock
```

--------------------------------

TITLE: Move On After a Timeout
DESCRIPTION: Creates a cancel scope that automatically cancels its operations after a specified duration. If the block finishes before the timeout, the scope is exited normally.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_12

LANGUAGE: Python
CODE:
```
async with anyio.move_on_after(5):
    await some_operation()
```

--------------------------------

TITLE: Set Total Tokens for CapacityLimiter
DESCRIPTION: Adds the `set_total_tokens()` method to the `CapacityLimiter` class. This allows users to dynamically adjust the total number of tokens available in a capacity limiter, providing more control over resource allocation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_224

LANGUAGE: Python
CODE:
```
import anyio

async def manage_capacity():
    limiter = anyio.CapacityLimiter(10)
    await limiter.set_total_tokens(20)
    # Further operations using the updated limiter
```

--------------------------------

TITLE: Fix Linux Abstract Namespace Support for UNIX Sockets
DESCRIPTION: Corrects a regression in v4.2 that broke support for Linux abstract namespaces in UNIX sockets.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_57

LANGUAGE: Python
CODE:
```
import anyio
import sys

async def connect_to_abstract_unix_socket(socket_name):
    if sys.platform.startswith("linux"):
        try:
            # Abstract namespace sockets are prefixed with null byte
            abstract_socket_path = b'\x00' + socket_name.encode('utf-8')

            # Attempt to connect using the abstract socket path
            # Note: anyio.connect_unix might need specific handling for abstract sockets
            # This example assumes direct support or a workaround.

            # A more robust solution might involve lower-level socket operations if anyio doesn't directly support it.
            # For demonstration, let's assume a hypothetical direct support:
            # stream = await anyio.connect_unix(abstract_socket_path)

            print(f"Attempting to connect to abstract socket: {socket_name}")
            # Placeholder for actual connection logic
            await anyio.sleep(1) # Simulate connection attempt
            print("Connection logic would go here.")

        except Exception as e:
            print(f"Error connecting to abstract socket: {e}")
    else:
        print("Abstract namespace UNIX sockets are a Linux-specific feature.")

# Example usage (requires a server listening on an abstract socket):
# anyio.run(connect_to_abstract_unix_socket, "my_abstract_socket")
```

--------------------------------

TITLE: Add Socket Parameters in AnyIO
DESCRIPTION: Version 1.4.0 of AnyIO adds 'family' and 'reuse_address' parameters to anyio.create_udp_socket() to enable multicast support.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_217

LANGUAGE: Python
CODE:
```
Added the family and reuse_address parameters to anyio.create_udp_socket()
```

--------------------------------

TITLE: Drop Support for Old-Style Coroutine Functions (AnyIO 4.0.0)
DESCRIPTION: AnyIO version 4.0.0 no longer supports spawning tasks from old-style coroutine functions decorated with `@asyncio.coroutine`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_80

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** Dropped support for spawning tasks from old-style coroutine
  functions (``@asyncio.coroutine``)
```

--------------------------------

TITLE: Add TaskInfo.has_pending_cancellation() Method
DESCRIPTION: Introduces the 'TaskInfo.has_pending_cancellation()' method, providing a way to check if a task has a pending cancellation request.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_61

LANGUAGE: Python
CODE:
```
import anyio

async def task_to_check():
    await anyio.sleep(10)

async def check_task_cancellation():
    task = await anyio.create_task(task_to_check())
    await anyio.sleep(0.1) # Allow task to start

    info = task.get_info()
    print(f"Initially, has pending cancellation: {info.has_pending_cancellation()}")

    task.cancel()
    await anyio.sleep(0.1) # Allow cancellation to be processed

    info = task.get_info()
    print(f"After cancelling, has pending cancellation: {info.has_pending_cancellation()}")

# anyio.run(check_task_cancellation)
```

--------------------------------

TITLE: TLS Stream Interface
DESCRIPTION: Defines the interface for streams secured with TLS, handling the encryption and decryption of data.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_62

LANGUAGE: Python
CODE:
```
async def send_secure_data(stream: anyio.streams.tls.TLSStream, data: bytes):
    await stream.send_bytes(data)
```

--------------------------------

TITLE: Low-level Checkpoint Functions
DESCRIPTION: Adds low-level checkpointing functions: `checkpoint()`, `checkpoint_if_cancelled()`, and `cancel_shielded_checkpoint()`. These provide fine-grained control over cancellation points in asynchronous code.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_166

LANGUAGE: Python
CODE:
```
anyio.lowlevel.checkpoint()
```

LANGUAGE: Python
CODE:
```
anyio.lowlevel.checkpoint_if_cancelled()
```

LANGUAGE: Python
CODE:
```
anyio.lowlevel.cancel_shielded_checkpoint()
```

--------------------------------

TITLE: Asyncio StreamWriter Close and Wait Closed
DESCRIPTION: Closing an asyncio stream requires calling close() followed by awaiting wait_closed() to confirm the stream has finished closing. AnyIO aims to simplify this process.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_11

LANGUAGE: Python
CODE:
```
writer.close()
await writer.wait_closed()
```

--------------------------------

TITLE: Stream Connectable Interfaces
DESCRIPTION: Defines interfaces for objects that can be connected to, representing network endpoints or other stream sources.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_47

LANGUAGE: Python
CODE:
```
connectable: anyio.abc.ByteStreamConnectable
stream = await anyio.connect_tcp('localhost', 8080)
```

--------------------------------

TITLE: Add SO_REUSEPORT to AnyIO Sockets
DESCRIPTION: This update adds support for the SO_REUSEPORT option to TCP listeners and UDP sockets in AnyIO, allowing multiple sockets to bind to the same address and port.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_211

LANGUAGE: Python
CODE:
```
Support for the SO_REUSEPORT option has been added to TCP listeners and UDP sockets
```

--------------------------------

TITLE: UNIXSocketStream for File Descriptors
DESCRIPTION: Adds the `UNIXSocketStream` class, enabling the sending and receiving of file descriptors over UNIX domain sockets. This is crucial for inter-process communication scenarios requiring file descriptor transfer.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_160

LANGUAGE: Python
CODE:
```
anyio.UNIXSocketStream
```

--------------------------------

TITLE: Run Synchronous Function from Worker Thread (AnyIO)
DESCRIPTION: Enables calling a synchronous function in the event loop thread from an AnyIO worker thread. It waits for the function to complete and returns its value, unlike asyncio's call_soon_threadsafe.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_15

LANGUAGE: Python
CODE:
```
anyio.from_thread.run_sync(func, *args, backend=None, backend_options=None)
```

--------------------------------

TITLE: Object Stream Interfaces
DESCRIPTION: Defines interfaces for reliable object streams, guaranteeing that data is delivered in order and without loss. Suitable for most application-level communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_44

LANGUAGE: Python
CODE:
```
async def send_objects(stream: anyio.abc.ObjectSendStream, objects):
    for obj in objects:
        await stream.send(obj)
```

--------------------------------

TITLE: Update TaskGroup for eager task factories
DESCRIPTION: Ensures `TaskGroup` functions correctly with asyncio's eager task factories.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_27

LANGUAGE: Python
CODE:
```
Updated ``TaskGroup`` to work with asyncio's eager task factories
  (`#764 <https://github.com/agronholm/anyio/issues/764>`_)
```

--------------------------------

TITLE: Fix CancelScope.cancel() on asyncio before scope entry
DESCRIPTION: Corrects an issue where CancelScope.cancel() did not function correctly on asyncio if called prior to entering the scope.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_105

LANGUAGE: Python
CODE:
```
from anyio import CancelScope

# Example scenario:
# scope = CancelScope()
# scope.cancel()
# with scope:
#     pass # Cancellation should now be handled correctly
```

--------------------------------

TITLE: Add Support for PEP 561
DESCRIPTION: Adds support for PEP 561, which concerns the distribution of type information in Python packages. This ensures that AnyIO packages can be correctly processed by type checkers and other tooling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_237

LANGUAGE: Python
CODE:
```
# No direct code snippet, but indicates package structure compliance
# This ensures type checkers like MyPy can understand AnyIO's types.
```

--------------------------------

TITLE: Run Synchronous Function in Worker Thread (AnyIO)
DESCRIPTION: Executes a synchronous function in a worker thread using AnyIO's thread pooling mechanism. It supports context variable propagation and allows specifying a capacity limiter.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/why.rst#_snippet_13

LANGUAGE: Python
CODE:
```
anyio.to_thread.run_sync(func, *args, limiter=None, cancellable=False, backend=None, backend_options=None)
```

--------------------------------

TITLE: Fix misleading ValueError on DNS failures
DESCRIPTION: Corrects a misleading `ValueError` that could be raised in scenarios involving DNS failures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_31

LANGUAGE: Python
CODE:
```
Fixed a misleading ``ValueError`` in the context of DNS failures
  (`#815 <https://github.com/agronholm/anyio/issues/815>`_; PR by @graingert)
```

--------------------------------

TITLE: Modify anyio.Path.relative_to() Signature (AnyIO 4.0.0)
DESCRIPTION: In AnyIO 4.0.0, the `anyio.Path.relative_to()` and `anyio.Path.is_relative_to()` methods were updated to accept only one argument, aligning with Python 3.12's deprecation of multiple arguments for these functions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_79

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** Changed ``anyio.Path.relative_to()`` and
  ``anyio.Path.is_relative_to()`` to only accept one argument, as passing multiple
  arguments is deprecated as of Python 3.12
```

--------------------------------

TITLE: AnyIO IPv6 Address Reporting
DESCRIPTION: This snippet explains a backwards-incompatible change in AnyIO 2.0.0 regarding IPv6 address reporting. IPv6 addresses are now reported as 2-tuples, with a non-zero scope ID appended to the address with '%' as a separator if present in the original 4-tuple.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_200

LANGUAGE: Python
CODE:
```
IPv6 addresses are now reported as 2-tuples. If original 4-tuple form contains a nonzero scope ID, it is appended to the address with "%" as the separator.
```

--------------------------------

TITLE: Fix SocketListener Close ValueError
DESCRIPTION: Resolves `ValueError: Invalid file descriptor: -1` when closing a `SocketListener` on asyncio, ensuring proper resource cleanup.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_193

LANGUAGE: Python
CODE:
```
asyncio SocketListener close()
```

--------------------------------

TITLE: Use asyncio.Runner on Asyncio Backend (AnyIO 4.0.0)
DESCRIPTION: AnyIO version 4.0.0 now utilizes `asyncio.Runner` (or a back-ported version for older Python versions) on the asyncio backend for running asynchronous operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_82

LANGUAGE: python
CODE:
```
Changed ``anyio.run()`` to use ``asyncio.Runner`` (or a back-ported version of it on
  Pythons older than 3.11) on the ``asyncio`` backend
```

--------------------------------

TITLE: Add feed_data() to BufferedByteReceiveStream
DESCRIPTION: Introduces the `feed_data()` method to the `BufferedByteReceiveStream` class, enabling direct data injection into the buffer. This is useful for managing stream data programmatically.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_0

LANGUAGE: Python
CODE:
```
from anyio.streams.buffered_io import BufferedByteReceiveStream

# Example usage:
# stream = BufferedByteReceiveStream()
# stream.feed_data(b'some data')

```

--------------------------------

TITLE: AnyIO Function Renames and Removals
DESCRIPTION: This snippet lists several backwards-incompatible changes in AnyIO 2.0.0, including function renames and removals. It highlights the replacement of `finalize()` with `contextlib.aclosing()` and renames for signal receivers, thread execution, and thread limiters.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_196

LANGUAGE: Python
CODE:
```
"finalize()" → (removed; use "contextlib.aclosing()" instead)
"receive_signals()" → "open_signal_receiver()"
"run_in_thread()" → "run_sync_in_worker_thread()"
"current_default_thread_limiter()" → "current_default_worker_thread_limiter()"
"ResourceBusyError" → "BusyResourceError"
```

--------------------------------

TITLE: Buffered Byte Receive Stream
DESCRIPTION: A byte stream that buffers data read from the underlying stream. This can improve performance by reducing the number of read operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_49

LANGUAGE: Python
CODE:
```
buffered_stream = anyio.streams.buffered.BufferedByteReceiveStream(underlying_stream)
```

--------------------------------

TITLE: Socket Read/Write Operations
DESCRIPTION: Enables waiting for socket readability or writability. This is crucial for non-blocking I/O operations, allowing programs to efficiently handle network events without blocking the main thread.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_70

LANGUAGE: Python
CODE:
```
anyio.wait_readable
anyio.wait_socket_readable
anyio.wait_socket_writable
anyio.wait_writable
```

--------------------------------

TITLE: Fix AssertionError with nest-asyncio
DESCRIPTION: Resolves an `AssertionError` that occurred when using the `nest-asyncio` library.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_25

LANGUAGE: Python
CODE:
```
Fixed ``AssertionError`` when using ``nest-asyncio``
  (`#840 <https://github.com/agronholm/anyio/issues/840>`_)
```

--------------------------------

TITLE: Worker Threads Spawned with daemon=True
DESCRIPTION: Ensures that worker threads are spawned with `daemon=True` across all AnyIO backends, not just trio. This setting allows the application to exit even if these worker threads are still running.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_250

LANGUAGE: Python
CODE:
```
# This is an internal implementation detail change, affecting how threads are managed.
```

--------------------------------

TITLE: Fix CapacityLimiter FIFO ordering on asyncio
DESCRIPTION: Ensures that waiting tasks for the CapacityLimiter on the asyncio backend are ordered in a First-In, First-Out (FIFO) manner, correcting a previous Last-In, First-Out (LIFO) behavior.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_104

LANGUAGE: Python
CODE:
```
from anyio import CapacityLimiter

# The CapacityLimiter now processes waiting tasks in the order they were added.
```

--------------------------------

TITLE: Fix Inconsistent Queue Capacity
DESCRIPTION: Corrects the inconsistent behavior of queue capacity across different AnyIO backends when the capacity is defined as 0. Previously, Trio treated 0 capacity as infinite, while others behaved differently. This fix harmonizes the behavior.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_246

LANGUAGE: Python
CODE:
```
import anyio

async def create_and_use_queue():
    queue = anyio.Queue(0) # Capacity is now consistently handled across backends
```

--------------------------------

TITLE: Update File I/O API in AnyIO
DESCRIPTION: This section details backwards incompatible changes to the asynchronous file I/O API in AnyIO, including the adoption of a common codebase and changes to function names.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_213

LANGUAGE: Python
CODE:
```
Asynchronous file I/O functionality now uses a common code base (anyio.AsyncFile) instead of backend-native classes
aopen() → open_file()
AsyncFileclose() → AsyncFileaclose()
```

--------------------------------

TITLE: Connect UDP Socket to Specific Destination
DESCRIPTION: Creates a UDP socket connected to a specific remote host and port. This allows sending data without specifying the destination address each time, optimizing for frequent transmissions to the same peer.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from anyio import create_connected_udp_socket, run


async def main():
    async with await create_connected_udp_socket(
            remote_host='hostname', remote_port=1234) as udp:
        await udp.send(b'Hi there!\n')

run(main)
```

--------------------------------

TITLE: Fix TLSStream TypeError on Windows with Truststore
DESCRIPTION: Resolves a TypeError occurring with TLSStream on Windows when a certificate verification error happens while using a truststore SSL certificate.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_45

LANGUAGE: Python
CODE:
```
import anyio

async def connect_with_truststore():
    try:
        # This connection might raise TypeError on Windows with truststore and verification errors
        stream = await anyio.connect_tls("example.com", 443, backend='asyncio', trust_roots=anyio.get_cancelled_exc_class())
        await stream.receive(1024)
    except Exception as e:
        print(f"An error occurred: {e}")
```

--------------------------------

TITLE: Fix TaskGroup traceback formatting in asyncio
DESCRIPTION: Addresses an issue where traceback formatting in `TaskGroup` could grow quadratically with nesting levels in asyncio, particularly when raising `ExceptionGroups` in `TaskGroup.__aexit__`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_18

LANGUAGE: Python
CODE:
```
Fixed traceback formatting growing quadratically with level of ``TaskGroup``
  nesting on asyncio due to exception chaining when raising ``ExceptionGroups``
  in ``TaskGroup.__aexit__``
  (`#863 <https://github.com/agronholm/anyio/issues/863>`_; PR by @tapetersen)
```

--------------------------------

TITLE: Writable CapacityLimiter Total Tokens
DESCRIPTION: Makes the `CapacityLimiter.total_tokens` property writable, allowing direct modification of the total available tokens. The `set_total_tokens()` method is now deprecated.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_170

LANGUAGE: Python
CODE:
```
anyio.CapacityLimiter.total_tokens
```

--------------------------------

TITLE: Run Async Function from Another Thread
DESCRIPTION: Allows running an asynchronous function from a synchronous thread. It bridges the gap between threaded and asynchronous code execution.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_25

LANGUAGE: Python
CODE:
```
anyio.from_thread.run(async_function, arg1)
```

--------------------------------

TITLE: Call Synchronous Code in Event Loop Thread (AnyIO)
DESCRIPTION: Illustrates how to call synchronous code that needs to interact with the event loop thread from a worker thread. This is necessary for thread-unsafe operations, using `anyio.from_thread.run_sync` to safely execute the call within the event loop's context.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_2

LANGUAGE: Python
CODE:
```
import time

from anyio import Event, from_thread, to_thread, run

def worker(event):
    time.sleep(1)
    from_thread.run_sync(event.set)

async def main():
    event = Event()
    await to_thread.run_sync(worker, event)
    await event.wait()

run(main)
```

--------------------------------

TITLE: Fix UNIX Socket Listener Non-Blocking Mode (Asyncio)
DESCRIPTION: Ensures that UNIX sockets created by a listener are set to non-blocking mode on asyncio.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_129

LANGUAGE: Python
CODE:
```
Fixed UNIX socket listener not setting accepted sockets to non-blocking mode on
  asyncio
```

--------------------------------

TITLE: Connect UNIX Datagram Socket to Specific Path
DESCRIPTION: Creates a UNIX datagram socket connected to a specific remote path. This is useful for sending multiple packets to a single destination without repeatedly specifying the path, similar to the connected UDP socket.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/networking.rst#_snippet_9

LANGUAGE: Python
CODE:
```
from anyio import create_connected_unix_datagram_socket, run


async def main():
    async with await create_connected_unix_datagram_socket(
        remote_path='/dev/log'
    ) as unix_dg:
        await unix_dg.send(b'Hi there!\n')

run(main)
```

--------------------------------

TITLE: Fix from_thread.run and run_sync Sniffio Issue on Asyncio
DESCRIPTION: Resolves an issue where `from_thread.run` and `from_thread.run_sync` did not correctly set sniffio on the asyncio backend. This fixes failures when calling sniffio-dependent functions and deadlocks in specific scenarios.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_87

LANGUAGE: python
CODE:
```
Fixed ``from_thread.run`` and ``from_thread.run_sync`` not setting sniffio on asyncio.
  As a result:

  - Fixed ``from_thread.run_sync`` failing when used to call sniffio-dependent functions
    on asyncio
  - Fixed ``from_thread.run`` failing when used to call sniffio-dependent functions on
    asyncio from a thread running trio or curio
  - Fixed deadlock when using ``from_thread.start_blocking_portal(backend="asyncio")``
    in a thread running trio or curio (PR by Ganden Schaffner)
```

--------------------------------

TITLE: Notify closing for wait_readable/wait_writable
DESCRIPTION: Adds `anyio.notify_closing` to wake up tasks waiting on `anyio.wait_readable` and `anyio.wait_writable` before a socket is closed. This prevents potential `OSError` exceptions, particularly on ProactorEventLoop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_4

LANGUAGE: Python
CODE:
```
import anyio

async def example():
    # Assume sock is a socket object
    # await anyio.wait_writable(sock)
    # anyio.notify_closing(sock)
    pass

```

--------------------------------

TITLE: FileReadStream and FileWriteStream
DESCRIPTION: Introduces `FileReadStream` and `FileWriteStream` for asynchronous file I/O operations. These classes provide an asynchronous interface for reading from and writing to files.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_161

LANGUAGE: Python
CODE:
```
anyio.FileReadStream
```

LANGUAGE: Python
CODE:
```
anyio.FileWriteStream
```

--------------------------------

TITLE: Fix RunVar name conflicts
DESCRIPTION: Corrects an issue where `RunVar` instances with the same name could incorrectly share storage. This ensures that each `RunVar` instance maintains its own independent storage, preventing name-based conflicts.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_10

LANGUAGE: Python
CODE:
```
import anyio

# Example usage:
# var1 = anyio.RunVar('my_var', default=1)
# var2 = anyio.RunVar('my_var', default=2)
# # Previously, var1 and var2 might have shared storage. Now they don't.

```

--------------------------------

TITLE: Fail After a Timeout
DESCRIPTION: Creates a cancel scope that raises an exception (typically `anyio.get_cancelled_exc_class()`) if the operations within it do not complete within the specified duration. This is useful for enforcing deadlines.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_13

LANGUAGE: Python
CODE:
```
async with anyio.fail_after(10):
    await long_running_operation()
```

--------------------------------

TITLE: AnyIO TLS and Buffering Changes
DESCRIPTION: This snippet details backwards-incompatible changes in AnyIO 2.0.0 related to TLS and buffering. TLS functionality is now split from `SocketStream` and can work over any bidirectional bytes-based stream. Buffering functions like `receive_until()` and `receive_exactly()` are now in a separate stream wrapper class.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_199

LANGUAGE: Python
CODE:
```
TLS functionality has been split off from `SocketStream` and can now work over any bidirectional bytes-based stream – you can now establish a TLS encrypted communications pathway over UNIX sockets or even memory object streams. The `TLSRequired` exception has also been removed as it is no longer necessary.
Buffering functionality (`receive_until()` and `receive_exactly()`) was split off from `SocketStream` into a stream wrapper class (`anyio.streams.buffered.BufferedByteReceiveStream`)
```

--------------------------------

TITLE: Fix KeyError in Cancel Scope on Asyncio/Curio
DESCRIPTION: Resolves a `KeyError` that occurred on asyncio and curio backends when entering and exiting a cancel scope across different tasks. This ensures correct state management for cancellation scopes in concurrent scenarios.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_248

LANGUAGE: Python
CODE:
```
import anyio

async def task_a():
    async with anyio.open_cancel_scope():
        pass

async def task_b():
    # This operation should now be safe without KeyErrors
```

--------------------------------

TITLE: AnyIO Cancellation Check with sleep(0)
DESCRIPTION: This snippet describes a change in AnyIO 2.0.0 for both asyncio and curio backends. A cancellation check now calls `sleep(0)`, which allows the scheduler to switch to a different task, improving responsiveness during cancellation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_204

LANGUAGE: Python
CODE:
```
a cancellation check now calls `sleep(0)`, allowing the scheduler to switch to a different task
```

--------------------------------

TITLE: Run Sync Function from Another Thread
DESCRIPTION: Executes a synchronous function from within an asynchronous context, typically when called from another thread. It ensures the synchronous function runs without blocking the event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_26

LANGUAGE: Python
CODE:
```
anyio.from_thread.run_sync(sync_function)
```

--------------------------------

TITLE: Fix Corner Cases of Cancellation
DESCRIPTION: Addresses several corner cases related to task cancellation, ensuring that AnyIO's behavior on asyncio and curio backends more closely matches that of trio. This leads to more consistent cancellation handling across different backends.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_257

LANGUAGE: Python
CODE:
```
import anyio

async def test_cancellation_consistency():
    # Test scenarios involving cancellation across different backends
```

--------------------------------

TITLE: Add Support for Python 3.12 and Drop Python 3.7 (AnyIO 4.0.0)
DESCRIPTION: AnyIO version 4.0.0 introduces support for Python 3.12 and drops support for Python 3.7, updating the minimum required Python version.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_83

LANGUAGE: python
CODE:
```
Dropped support for Python 3.7
Added support for Python 3.12
```

--------------------------------

TITLE: AnyIO Socket API Changes
DESCRIPTION: This snippet details backwards-incompatible changes to the AnyIO socket API in version 2.0.0. It includes changes to TCP and UDP server creation functions, parameter renames for UDP socket creation, and modifications to TCP connection parameters, including TLS handling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_197

LANGUAGE: Python
CODE:
```
"create_tcp_server()" → "create_tcp_listener()"
"create_unix_server()" → "create_unix_listener()"
"create_udp_socket()" had some of its parameters changed:

  "interface" → "local_address"
  "port" → "local_port"
  "reuse_address" was replaced with "reuse_port" (and sets "SO_REUSEPORT" instead of "SO_REUSEADDR")
"connect_tcp()" had some of its parameters changed:

  "address" → "remote_address"
  "port" → "remote_port"
  "bind_host" → "local_address"
  "bind_port" → (removed)
  "autostart_tls" → "tls"
  "tls_hostname" (new parameter, when you want to match the certificate against against something else than "remote_address")
```

--------------------------------

TITLE: Socket ABCs
DESCRIPTION: Defines abstract base classes for various socket types, including generic socket attributes, stream sockets, UDP sockets, and UNIX domain sockets. These classes provide a common interface for interacting with different socket implementations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_71

LANGUAGE: Python
CODE:
```
anyio.abc.SocketAttribute
anyio.abc.SocketStream
anyio.abc.SocketListener
anyio.abc.UDPSocket
anyio.abc.ConnectedUDPSocket
anyio.abc.UNIXSocketStream
anyio.abc.UNIXDatagramSocket
anyio.abc.ConnectedUNIXDatagramSocket
```

--------------------------------

TITLE: Fix Socket Creation Failure Crashing connect_tcp()
DESCRIPTION: Prevents `connect_tcp()` from crashing due to socket creation failures. The function now handles these errors more gracefully, ensuring that connection attempts do not terminate the entire process.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_247

LANGUAGE: Python
CODE:
```
import anyio

async def connect_safely(host, port):
    try:
        async with await anyio.connect_tcp(host, port) as stream:
            pass
    except Exception as e:
        print(f"Connection failed: {e}") # Handles socket creation errors
```

--------------------------------

TITLE: Fix Deprecation Warnings for asyncio.Event()
DESCRIPTION: Addresses deprecation warnings related to the `loop` argument of `asyncio.Event()` on Python 3.8. This update ensures compatibility with newer Python versions and removes unnecessary warnings.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_249

LANGUAGE: Python
CODE:
```
import anyio
import asyncio

async def use_event_without_warnings():
    # The asyncio backend now handles Event creation correctly without the loop argument
```

--------------------------------

TITLE: Fix Cancellation Exception Bubbling in Except* Blocks (AnyIO)
DESCRIPTION: Corrects a discrepancy between asyncio and trio regarding how cancellation exceptions bubble out of cancel scopes when reraised in an 'except*' block. This ensures consistent cancellation behavior across backends.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_75

LANGUAGE: python
CODE:
```
Fixed discrepancy between ``asyncio`` and ``trio`` where reraising a cancellation
  exception in an ``except*`` block would incorrectly bubble out of its cancel scope
  (`#634 <https://github.com/agronholm/anyio/issues/634>`_)
```

--------------------------------

TITLE: Fix RuntimeError in start_blocking_portal on event loop close
DESCRIPTION: Prevents an unwarranted RuntimeError: 'This portal is not running' when a task raises an exception that causes the event loop to close.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_108

LANGUAGE: Python
CODE:
```
from anyio import start_blocking_portal

# The fix ensures proper handling of exceptions during portal operation
# when the underlying event loop is being shut down.
```

--------------------------------

TITLE: Fix OP_IGNORE_UNEXPECTED_EOF flag in TLSStream.wrap()
DESCRIPTION: Addresses an issue where the OP_IGNORE_UNEXPECTED_EOF flag was inadvertently set on Python 3.11.3 and 3.10.11 for SSL contexts created by default in TLSStream.wrap().

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_110

LANGUAGE: Python
CODE:
```
from anyio.streams.tls import TLSStream

# The fix ensures the flag is not incorrectly applied on specific Python versions.
```

--------------------------------

TITLE: Fix Trio v0.13 Compatibility on Windows
DESCRIPTION: Ensures compatibility with Trio version 0.13 specifically on Windows operating systems. This resolves potential issues that may arise from differences in how Trio handles concurrency on Windows.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_245

LANGUAGE: Python
CODE:
```
# No direct code snippet, but indicates internal adjustments for Trio compatibility on Windows.
```

--------------------------------

TITLE: Fix Type Annotation for DeprecatedAwaitable
DESCRIPTION: Updates the type annotation for ``DeprecatedAwaitable(|List|Float).__await__`` to align with the ``typing.Awaitable`` protocol.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_150

LANGUAGE: Python
CODE:
```
Fixed the type annotation of ``DeprecatedAwaitable(|List|Float).__await__`` to match
  the ``typing.Awaitable`` protocol
```

--------------------------------

TITLE: Fix Process stdin/stdout/stderr aclose checkpoint on asyncio
DESCRIPTION: Ensures that closing the standard input, output, or error streams of a process on the asyncio backend includes a checkpoint, preventing potential issues during cancellation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_66

LANGUAGE: Python
CODE:
```
async def aclose(self) -> None:
    """Close the stream."""
    # ... implementation details ...
    pass
```

--------------------------------

TITLE: Fix CapacityLimiter edge case on asyncio
DESCRIPTION: Resolves an edge case in `CapacityLimiter` on the asyncio backend where a cancelled task waiting for a token might incorrectly receive and use the token, failing to notify the next waiting task. This ensures fair token distribution.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_12

LANGUAGE: Python
CODE:
```
import anyio

# async def use_capacity_limiter():
#     limiter = anyio.CapacityLimiter(1)
#     async with limiter:
#         # acquire token
#         pass

```

--------------------------------

TITLE: Fix rollover boundary check in SpooledTemporaryFile
DESCRIPTION: Addresses an issue in `SpooledTemporaryFile` where the rollover boundary check was too strict. The fix ensures rollover only occurs when the buffer size actually exceeds `max_size`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_7

LANGUAGE: Python
CODE:
```
from anyio.tempfile import SpooledTemporaryFile

# Example usage:
# with SpooledTemporaryFile(max_size=1024) as tmp:
#     tmp.write(b'data' * 500)
#     # Rollover occurs here if buffer exceeds 1024 bytes

```

--------------------------------

TITLE: Improve type annotations for coroutine-like inputs
DESCRIPTION: Several functions and methods now accept 'Awaitable[Any]' instead of 'Coroutine[Any, Any, Any]' for return types of callables. This broadens compatibility with coroutine-like inputs, such as async generator asend objects.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_102

LANGUAGE: Python
CODE:
```
from typing import Any, Awaitable

# Example of updated type hint:
def run_async_function(func: Callable[[], Awaitable[Any]]) -> None:
    pass
```

--------------------------------

TITLE: Use Capacity Limiters for Thread Pool
DESCRIPTION: Adds the capability to use capacity limiters for controlling the maximum number of threads that can be spawned or used. This enhances resource management for thread-based operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_232

LANGUAGE: Python
CODE:
```
import anyio

async def run_with_thread_limit():
    thread_limiter = anyio.CapacityLimiter(5) # Limit to 5 threads
    await anyio.run_in_thread(some_function, limiter=thread_limiter)
```

--------------------------------

TITLE: AnyIO API Changes: Submodules, Method Signatures, and Renames
DESCRIPTION: Details backwards incompatible changes in AnyIO 3.0.0, including making submodules private, converting coroutine methods to synchronous, and renaming/moving functions. It also notes changes in context manager behavior and method signatures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_157

LANGUAGE: Python
CODE:
```
# Old usage (now deprecated or removed):
# import anyio.abc.submodule
# await anyio.current_time()
# async with anyio.open_cancel_scope(): ...
# await anyio.create_blocking_portal()

# New usage:
import anyio

# Accessing ABCs directly from anyio
# Example: anyio.abc.Task

# Synchronous methods (previously coroutines):
# MemoryObjectReceiveStream.receive_nowait()

# Awaiting these now emits a deprecation warning:
# await anyio.current_time()

# Synchronous context managers:
# with anyio.CancelScope() as scope: ...

# Renamed/moved functions:
# portal = anyio.from_thread.BlockingPortal()
# limiter = anyio.CapacityLimiter()
# event = anyio.Event()
# lock = anyio.Lock()
# condition = anyio.Condition()
# semaphore = anyio.Semaphore()
# anyio.to_thread.current_default_thread_limiter()
# scope = anyio.CancelScope()
# anyio.to_thread.run_sync(lambda: None)
# anyio.from_thread.run(lambda: None)
# anyio.from_thread.run_sync(lambda: None)

# BlockingPortal usage:
# with anyio.from_thread.BlockingPortal() as portal:
#     portal.start_task_soon(lambda: None)
#     portal.stop_from_external_thread() # Use portal.call(portal.stop) instead

# TaskGroup usage:
# async with anyio.create_task_group() as tg:
#     tg.start_soon(lambda: None) # Previously tg.spawn()

# CapacityLimiter usage:
# limiter.total_tokens = 10 # Previously limiter.set_total_tokens(10)
```

--------------------------------

TITLE: Fix IPv6 Support in Network Functions
DESCRIPTION: Improves IPv6 support in several network functions, including `create_tcp_server()`, `connect_tcp()`, and `create_udp_socket()`. This ensures reliable operation with IPv6 addresses.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_252

LANGUAGE: Python
CODE:
```
import anyio

async def create_ipv6_server():
    server = await anyio.create_tcp_server(port=8080, family=socket.AF_INET6)
    # IPv6 server creation is now reliable
```

--------------------------------

TITLE: Fix MemoryObjectItemReceiver __repr__
DESCRIPTION: Corrects the '__repr__()' method of 'MemoryObjectItemReceiver' when the 'item' attribute is not defined, preventing potential errors.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_51

LANGUAGE: Python
CODE:
```
import anyio

# Assuming MemoryObjectItemReceiver is part of anyio's internal implementation
# This is a conceptual example of how the fix might be applied.

class MockMemoryObjectItemReceiver:
    def __init__(self, item=None):
        self.item = item

    def __repr__(self):
        if self.item is not None:
            return f"MockMemoryObjectItemReceiver(item={self.item!r})"
        else:
            return "MockMemoryObjectItemReceiver(item=undefined)"

# Example usage:
receiver_with_item = MockMemoryObjectItemReceiver(item=123)
print(repr(receiver_with_item))

receiver_without_item = MockMemoryObjectItemReceiver()
print(repr(receiver_without_item))
```

--------------------------------

TITLE: Fix Unnecessary Delay in connect_tcp()
DESCRIPTION: Eliminates an unnecessary delay in `connect_tcp()` that occurred when an earlier connection attempt succeeded. This optimization improves the performance of establishing TCP connections.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_242

LANGUAGE: Python
CODE:
```
import anyio

async def connect_efficiently(host, port):
    async with await anyio.connect_tcp(host, port) as stream:
        # Connection established without unnecessary delays
```

--------------------------------

TITLE: Fix SocketStream.receive() returning bytearray on Windows Asyncio
DESCRIPTION: Corrects an issue where SocketStream.receive() returned a 'bytearray' instead of 'bytes' when using asyncio with ProactorEventLoop on Windows.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_55

LANGUAGE: Python
CODE:
```
import anyio
import sys

async def receive_bytes_on_windows():
    if sys.platform == "win32":
        try:
            # This requires setting up a server and client connection
            # For demonstration, we'll simulate the expected behavior.
            # In a real scenario, you'd connect to a server.

            # Mocking a stream that might return bytearray
            class MockSocketStream:
                async def receive(self, max_bytes):
                    return bytearray(b'test data') # Simulating the problematic return type

            stream = MockSocketStream()
            data = await stream.receive(10)

            # The fix ensures 'data' is bytes
            if isinstance(data, bytearray):
                print("Received data is bytearray (potential issue).")
                data = bytes(data)

            print(f"Received data type: {type(data)}")
            print(f"Received data: {data}")

        except Exception as e:
            print(f"An error occurred: {e}")
    else:
        print("This test is specific to Windows with ProactorEventLoop.")

# anyio.run(receive_bytes_on_windows)
```

--------------------------------

TITLE: Fix to_thread.run_sync() hanging on StopIteration on asyncio
DESCRIPTION: Resolves a hang issue in to_thread.run_sync() on asyncio when the target callable raises StopIteration.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_107

LANGUAGE: Python
CODE:
```
from anyio.to_thread import run_sync

# def function_raising_stop_iteration():
#     raise StopIteration

# run_sync(function_raising_stop_iteration) # Should no longer hang
```

--------------------------------

TITLE: Update asyncio Backend Policy Option to loop_factory (AnyIO 4.0.0)
DESCRIPTION: The 'policy' option for the asyncio backend in AnyIO has been renamed to 'loop_factory' in version 4.0.0 to better accommodate `asyncio.Runner`.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_81

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** The ``policy`` option on the ``asyncio`` backend was
  changed to ``loop_factory`` to accommodate ``asyncio.Runner``
```

--------------------------------

TITLE: Bump Minimum Trio Version (AnyIO 4.0.0)
DESCRIPTION: AnyIO version 4.0.0 increases the minimum required version of the trio library to v0.22.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_84

LANGUAGE: python
CODE:
```
Bumped minimum version of trio to v0.22
```

--------------------------------

TITLE: AnyIO curio Backend Fixes
DESCRIPTION: This snippet outlines fixes and improvements for the AnyIO curio backend in version 2.0.0. It addresses a limitation where tasks could only be cancelled twice and includes workarounds for task cancellation issues.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_203

LANGUAGE: Python
CODE:
```
Worked around the limitation where a task can only be cancelled twice (any cancellations beyond that were ignored)
```

--------------------------------

TITLE: Support voluntary thread cancellation
DESCRIPTION: Introduces `anyio.from_thread.check_cancelled()` to allow voluntary thread cancellation, enabling threads to periodically check if they have been requested to cancel.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_73

LANGUAGE: Python
CODE:
```
from anyio.from_thread import check_cancelled

def my_thread_function():
    # ... some work ...
    check_cancelled()
    # ... more work ...
    pass
```

--------------------------------

TITLE: Add Support for CancelScope.shield Mutation
DESCRIPTION: Enables mutation of ``CancelScope.shield``, providing more control over cancellation behavior. This feature was contributed by John Belmonte.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_152

LANGUAGE: Python
CODE:
```
Added support for mutation of ``CancelScope.shield`` (PR by John Belmonte)
```

--------------------------------

TITLE: Improve type annotations with TypeVarTuple
DESCRIPTION: Enhances type checking for functions accepting variadic positional arguments by utilizing PEP 646 TypeVarTuple, improving static analysis for various AnyIO functions and methods.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_69

LANGUAGE: Python
CODE:
```
from typing import TypeVarTuple, Tuple

Ts = TypeVarTuple('Ts')

def start_soon(self, func: Callable[..., Any], *args: Unpack[Ts]) -> None:
    """Start a new task in the task group."""
    pass

def run(*args: Unpack[Ts]) -> None:
    """Run a function until completion."""
    pass
```

--------------------------------

TITLE: Run Synchronous Function in a Worker Process
DESCRIPTION: Executes a synchronous function in a separate worker process. This offers strong isolation and is suitable for CPU-bound tasks or running code that requires a different Python environment.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_23

LANGUAGE: Python
CODE:
```
result = await anyio.to_process.run_sync(sync_function, arg1, process_pool=my_pool)
```

--------------------------------

TITLE: Add Lock Parameter to create_condition()
DESCRIPTION: Adds the `lock` parameter to the `anyio.create_condition()` function. This allows users to specify a custom lock object to be used with the condition variable, offering more flexibility in synchronization.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_229

LANGUAGE: Python
CODE:
```
import anyio

async def use_custom_lock_condition():
    custom_lock = anyio.Lock()
    condition = anyio.create_condition(lock=custom_lock)
    # Use the condition variable with the custom lock
```

--------------------------------

TITLE: Force WindowsSelectorEventLoopPolicy on Windows
DESCRIPTION: Forces the use of `WindowsSelectorEventLoopPolicy` in `asyncio.run` when running on Windows with the asyncio backend. This ensures network functionality remains stable and avoids potential issues with default loop policies.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_228

LANGUAGE: Python
CODE:
```
import anyio
import asyncio
import sys

async def run_asyncio_app():
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    # Run application logic
    pass

# AnyIO's asyncio backend will now automatically apply this policy on Windows
```

--------------------------------

TITLE: Fix Timeout Errors in AnyIO
DESCRIPTION: Version 1.4.0 addresses issues with timeout errors in AnyIO, specifically fixing fail.after(0) on asyncio and curio, and ensuring socket operations correctly cancel tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_218

LANGUAGE: Python
CODE:
```
Fixed fail.after(0) not raising a timeout error on asyncio and curio
Fixed socket operations not allowing timeouts to cancel the task
```

--------------------------------

TITLE: Fix Open Signal Receiver Hanging
DESCRIPTION: Resolves an issue where `open_signal_receiver()` on asyncio and curio could hang if the cancel scope was cancelled before the function could run.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_184

LANGUAGE: Python
CODE:
```
anyio.open_signal_receiver()
```

--------------------------------

TITLE: Configure AnyIO TLSListener for Non-Standard Shutdown
DESCRIPTION: Shows how to configure AnyIO's TLSListener to disable the standard TLS closing handshake. This is necessary for protocols that do not strictly follow the TLS standard for connection termination.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/streams.rst#_snippet_10

LANGUAGE: Python
CODE:
```
# Example usage with TLSListener:
# listener = TLSListener(..., standard_compatible=False)

# Example usage with TLSStream.wrap:
# wrapped_stream = await TLSStream.wrap(..., standard_compatible=False)
```

--------------------------------

TITLE: Forcefully Close an Async Resource
DESCRIPTION: Immediately closes an asynchronous resource, even if it is currently in use. This is typically used for cleanup operations when normal closing is not possible.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_7

LANGUAGE: Python
CODE:
```
await anyio.aclose_forcefully(resource)
```

--------------------------------

TITLE: Asyncio Thread Limiter RunVar
DESCRIPTION: Uses `RunVar` for the default thread limiter on asyncio, scoping it to the current event loop to prevent conflicts between multiple running event loops.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_176

LANGUAGE: Python
CODE:
```
asyncio.RunVar
```

--------------------------------

TITLE: Memory Object Stream Statistics
DESCRIPTION: Provides statistics about the performance and usage of memory object streams, such as the number of items sent or received.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_55

LANGUAGE: Python
CODE:
```
stats = anyio.streams.memory.MemoryObjectStreamStatistics(items_sent=10, items_received=10)
```

--------------------------------

TITLE: Fix anyio.Path.iterdir() blocking call in Python 3.13
DESCRIPTION: Resolves a problem where `anyio.Path.iterdir()` would make a blocking call when used with Python 3.13.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_19

LANGUAGE: Python
CODE:
```
Fixed ``anyio.Path.iterdir()`` making a blocking call in Python 3.13
  (`#873 <https://github.com/agronholm/anyio/issues/873>`_; PR by @cbornet and
  @agronholm)
```

--------------------------------

TITLE: Handle IPv6 name resolution results
DESCRIPTION: Modifies `anyio.getaddrinfo()` to ignore invalid IPv6 name resolution results when IPv6 support is disabled in Python. This prevents potential errors and ensures more robust network address lookups.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_17

LANGUAGE: Python
CODE:
```
import anyio

# async def get_addresses():
#     # Example: get address info, handling potential IPv6 issues
#     addresses = await anyio.getaddrinfo('example.com', 80)
#     print(addresses)

```

--------------------------------

TITLE: Fix AnyIO processes being lost in process pool
DESCRIPTION: Resolves an issue where processes spawned by anyio.to_process() became unusable after idling for over 5 minutes due to pruning in to_process.run_sync(). This led to increased memory consumption.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_100

LANGUAGE: Python
CODE:
```
from anyio import to_process

# The fix ensures that pruned processes are handled correctly
# and do not become 'lost' to the process pool.
```

--------------------------------

TITLE: Fix Timeouts Not Propagating on Asyncio/Curio
DESCRIPTION: Resolves an issue where timeouts did not propagate correctly from nested cancel scopes on asyncio and curio backends. This ensures that nested timeouts are handled as expected.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_255

LANGUAGE: Python
CODE:
```
import anyio

async def nested_timeout_operation():
    async with anyio.open_cancel_scope(deadline=10):
        async with anyio.open_cancel_scope(deadline=5):
            # This inner scope's timeout should now propagate correctly
```

--------------------------------

TITLE: Change Default uvloop Option (Asyncio)
DESCRIPTION: Modifies the default value of the ``use_uvloop`` asyncio backend option to ``False``. This change prevents unsafe event loop policy modifications across different threads.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_145

LANGUAGE: Python
CODE:
```
Changed the default value of the ``use_uvloop`` asyncio backend option to ``False`` to
  prevent unsafe event loop policy changes in different threads
```

--------------------------------

TITLE: Fix anyio.Path type annotations
DESCRIPTION: Corrects various type annotations for the anyio.Path class to align with Typeshed definitions, ensuring better compatibility and accuracy with static type checkers.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_70

LANGUAGE: Python
CODE:
```
class Path:
    def __lt__(self, other: 'Path') -> bool:
        """Compare paths less than."""
        pass

    def hardlink_to(self, target: 'Path') -> 'Path':
        """Create a hardlink."""
        pass

    def symlink_to(self, target: str | 'Path') -> 'Path':
        """Create a symbolic link."""
        pass
```

--------------------------------

TITLE: Add Python 3.10 Compatibility
DESCRIPTION: Ensures AnyIO is compatible with Python version 3.10.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_143

LANGUAGE: Python
CODE:
```
Added Python 3.10 compatibility
```

--------------------------------

TITLE: AnyIO Stream API Overhaul
DESCRIPTION: This snippet summarizes the backwards-incompatible overhaul of the AnyIO stream class structure in version 2.0.0. It introduces separate abstract base classes for receive and send streams, byte streams, and object streams, improving support for stream wrappers and a new 'typed extra attribute' system.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_198

LANGUAGE: Python
CODE:
```
The stream class structure was completely overhauled. There are now separate abstract base classes for receive and send streams, byte streams and reliable and unreliable object streams. Stream wrappers are much better supported by this new ABC structure and a new "typed extra attribute" system that lets you query the wrapper chain for the attributes you want via ".extra(...)".
```

--------------------------------

TITLE: Synchronous Closing of Memory Object Streams
DESCRIPTION: Enables the closing of memory object streams synchronously, including support for their use as synchronous context managers.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_144

LANGUAGE: Python
CODE:
```
Added the ability to close memory object streams synchronously (including support for
  use as a synchronous context manager)
```

--------------------------------

TITLE: Improve Type Annotations for MemoryObjectStream (AnyIO)
DESCRIPTION: Enhances type annotations for `create_memory_object_stream`. The `item_type` argument is now deprecated in favor of generic type hinting (e.g., `create_memory_object_stream[T_Item]()`), improving type checking with uninstantiable item types.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_88

LANGUAGE: python
CODE:
```
Improved type annotations:

  - The ``item_type`` argument of ``create_memory_object_stream`` was deprecated.
    To indicate the item type handled by the stream, use
    ``create_memory_object_stream[T_Item]()`` instead. Type checking should no longer
    fail when annotating memory object streams with uninstantiable item types (PR by
    Ganden Schaffner)
```

--------------------------------

TITLE: Workaround PyPy bug with anyio.getaddrinfo() and IPv6
DESCRIPTION: Addresses a PyPy bug encountered when using anyio.getaddrinfo() with IPv6 link-local addresses that include interface names.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_113

LANGUAGE: Python
CODE:
```
from anyio import getaddrinfo

# The workaround ensures that getaddrinfo functions correctly with IPv6
# link-local addresses containing interface names on PyPy.
```

--------------------------------

TITLE: AnyIO Socket Concurrency Guards
DESCRIPTION: This update introduces guards to prevent concurrent read/write operations on sockets by multiple tasks, enhancing stability and preventing race conditions. It also adds the `notify_socket_close()` function for better socket management.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_265

LANGUAGE: Python
CODE:
```
def notify_socket_close():
    # Implementation details for notifying socket closure
    pass
```

--------------------------------

TITLE: Override Typed Attributes in a Subclass
DESCRIPTION: Demonstrates how to override existing typed attributes in a subclass by inheriting from a `TypedAttributeProvider` and redefining the `extra_attributes` property, ensuring to include the parent's attributes.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/typedattrs.rst#_snippet_3

LANGUAGE: Python
CODE:
```
class AnotherAttributeProvider(MyAttributeProvider):
    @property
    def extra_attributes() -> Mapping[Any, Callable[[], Any]]:
        return {
            **super().extra_attributes,
            MyTypedAttribute.string_valued_attribute: lambda: 'overridden attribute value'
        }
```

--------------------------------

TITLE: Provide Python 3.8 regression fix
DESCRIPTION: An interim release to address a regression affecting Python 3.8, also incorporating fixes present in v4.6.1.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_42

LANGUAGE: Python
CODE:
```
As Python 3.8 support was dropped in v4.6.0, this interim release was created to bring a
  regression fix to Python 3.8, and adds a few other fixes also present in v4.6.1.
```

--------------------------------

TITLE: Task Status Interface
DESCRIPTION: Represents the status of a task within a task group, allowing for synchronization and signaling between tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_18

LANGUAGE: Python
CODE:
```
async def worker(task_status: anyio.abc.TaskStatus):
    task_status.started()
    await do_work()
    task_status.finished()
```

--------------------------------

TITLE: Fix MultiListener Extra Method
DESCRIPTION: Fixes a broken `MultiListener.extra()` method, ensuring its functionality is restored.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_195

LANGUAGE: Python
CODE:
```
anyio.MultiListener.extra()
```

--------------------------------

TITLE: Fix SyntaxWarning for return in finally on Python 3.14
DESCRIPTION: Eliminates a `SyntaxWarning` related to using `return` within a `finally` block, specifically on Python 3.14. This improves code cleanliness and adherence to Python's syntax guidelines.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_9

LANGUAGE: Python
CODE:
```
import anyio

async def safe_operation():
    try:
        # operation that might raise an exception
        pass
    finally:
        # Code here should not use 'return' if it might be reached
        # during exception handling in a way that causes the warning.
        pass

```

--------------------------------

TITLE: Fix RuntimeError in Async Generator Fixtures (AnyIO)
DESCRIPTION: Addresses a RuntimeError that occurred when running higher-scoped async generator fixtures in certain scenarios within the AnyIO framework. This fix ensures smoother execution of asynchronous fixtures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_74

LANGUAGE: python
CODE:
```
Fixed ``RuntimeError: Runner is closed`` when running higher-scoped async generator
  fixtures in some cases (`#619 <https://github.com/agronholm/anyio/issues/619>`_)
```

--------------------------------

TITLE: Fix Socket Stream Send Exception
DESCRIPTION: Ensures `send()` on socket streams raises appropriate exceptions on asyncio (e.g., `BrokenPipeError`) and Trio/Curio when the peer disconnects, improving error reporting.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_191

LANGUAGE: Python
CODE:
```
socket streams send()
```

--------------------------------

TITLE: Fix Current Effective Deadline KeyError
DESCRIPTION: Fixes `current_effective_deadline()` raising `KeyError` on asyncio when no cancel scope is active, ensuring correct behavior in all scenarios.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_178

LANGUAGE: Python
CODE:
```
anyio.current_effective_deadline()
```

--------------------------------

TITLE: Fix Race Condition with Multiple Event Loops
DESCRIPTION: Resolves a race condition that could lead to crashes when multiple event loops of the same backend were running concurrently in separate threads and attempting to use AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_64

LANGUAGE: Python
CODE:
```
import anyio
import threading

async def worker_task():
    # Simulate using AnyIO resources within a thread-specific event loop
    try:
        await anyio.sleep(0.1)
        print(f"Worker task running in thread: {threading.current_thread().name}")
    except Exception as e:
        print(f"Error in worker task: {e}")

def run_in_thread():
    # Each thread needs its own event loop managed by AnyIO
    anyio.run(worker_task, backend='asyncio')

# Example of how to trigger the scenario (requires careful setup):
# threads = []
# for i in range(3):
#     thread = threading.Thread(target=run_in_thread, name=f"Worker-{i}")
#     threads.append(thread)
#     thread.start()
#
# for thread in threads:
#     thread.join()
```

--------------------------------

TITLE: Update SocketStream Methods in AnyIO
DESCRIPTION: This snippet details the changes to methods and attributes of the SocketStream class in AnyIO. It highlights the renaming of parameters and the replacement of certain methods with new ones or different approaches.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_208

LANGUAGE: Python
CODE:
```
address → .extra(SocketAttribute.local_address)
alpn_protocol → .extra(TLSAttribute.alpn_protocol)
close() → aclose()
get_channel_binding → .extra(TLSAttribute.channel_binding_tls_unique)
cipher → .extra(TLSAttribute.cipher)
getpeercert → .extra(SocketAttribute.peer_certificate) or .extra(SocketAttribute.peer_certificate_binary)
getsockopt() → .extra(SocketAttribute.raw_socket).getsockopt(...)
peer_address → .extra(SocketAttribute.remote_address)
receive_chunks() → (removed; use async for on the stream instead)
receive_delimited_chunks() → (removed)
receive_exactly() → BufferedReceiveStream.receive_exactly()
receive_some() → receive()
receive_until() → BufferedReceiveStream.receive_until()
send_all() → send()
setsockopt() → .extra(SocketAttribute.raw_socket).setsockopt(...)
shared_ciphers → .extra(TLSAttribute.shared_ciphers)
server_side → .extra(TLSAttribute.server_side)
start_tls() → stream = TLSStream.wrap(...)
tls_version → .extra(TLSAttribute.tls_version)
```

--------------------------------

TITLE: Fix Asyncio Warning on Unretrieved Future (Socket Write)
DESCRIPTION: Addresses an asyncio warning related to a ``Future`` with an unretrieved exception. This occurred when a socket write operation was followed by an abrupt peer connection closure.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_135

LANGUAGE: Python
CODE:
```
Fixed asyncio warning about a ``Future`` with an exception that was never retrieved
  which happened when a socket was already written to but the peer abruptly closed the
  connection
```

--------------------------------

TITLE: Add Capacity Limiters
DESCRIPTION: Introduces capacity limiters as a feature within AnyIO. Capacity limiters are used to control the rate or number of concurrent operations, helping to manage resource usage and prevent overload.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_231

LANGUAGE: Python
CODE:
```
import anyio

async def use_capacity_limiter():
    limiter = anyio.CapacityLimiter(10) # Limit to 10 concurrent operations
    async with limiter:
        # Perform an operation that is subject to the capacity limit
```

--------------------------------

TITLE: Fix current_effective_deadline() with Shielded Scopes
DESCRIPTION: Ensures that `current_effective_deadline()` correctly accounts for shielded cancellation scopes on asyncio and curio backends. This provides accurate deadline information even when cancellation is shielded.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_258

LANGUAGE: Python
CODE:
```
import anyio

async def check_deadline_with_shield():
    async with anyio.open_cancel_scope(shield=True):
        deadline = anyio.current_effective_deadline()
        # deadline should now be correctly calculated
```

--------------------------------

TITLE: Fix Worker Threads Marked as Event Loop Threads (Sniffio)
DESCRIPTION: Corrects a bug where worker threads were incorrectly marked as event loop threads by the sniffio library.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_125

LANGUAGE: Python
CODE:
```
Fixed worker threads being marked as being event loop threads in sniffio
```

--------------------------------

TITLE: Drop async_generator Dependency
DESCRIPTION: Removes the unnecessary dependency on the ``async_generator`` library from AnyIO.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_139

LANGUAGE: Python
CODE:
```
Dropped unnecessary dependency on the ``async_generator`` library
```

--------------------------------

TITLE: Fix ExceptionGroup Formatted Output
DESCRIPTION: Addresses an issue with the formatted output of `ExceptionGroup` containing excessive newlines, improving the readability of grouped exceptions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_186

LANGUAGE: Python
CODE:
```
anyio.ExceptionGroup
```

--------------------------------

TITLE: Fix TaskGroup/CancelScope cyclic references
DESCRIPTION: Resolves an issue where `TaskGroup` and `CancelScope` could produce cyclic references in tracebacks when exceptions were raised.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_36

LANGUAGE: Python
CODE:
```
Fixed TaskGroup and CancelScope producing cyclic references in tracebacks
  when raising exceptions (`#806 <https://github.com/agronholm/anyio/pull/806>`_)
  (PR by @graingert)
```

--------------------------------

TITLE: Fix asyncio test runner exception handling
DESCRIPTION: Corrects the exception handler in the asyncio test runner to properly manage contexts that do not contain the 'exception' key.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_115

LANGUAGE: Python
CODE:
```
# The test runner's exception handling logic has been updated to be more robust.
```

--------------------------------

TITLE: Fix Task Parent ID Setting (Asyncio)
DESCRIPTION: Ensures the task parent ID is correctly set in asyncio environments.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_126

LANGUAGE: Python
CODE:
```
Fixed task parent ID not getting set to the correct value on asyncio
```

--------------------------------

TITLE: Call Async Code from Worker Thread (AnyIO)
DESCRIPTION: Shows how to call an asynchronous function (coroutine) from a synchronous function running in a worker thread. This is achieved using `anyio.from_thread.run`, which bridges the worker thread back to the AnyIO event loop to execute the coroutine.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_1

LANGUAGE: Python
CODE:
```
from anyio import from_thread, sleep, to_thread, run


def blocking_function():
    from_thread.run(sleep, 5)


async def main():
    await to_thread.run_sync(blocking_function)

run(main)
```

--------------------------------

TITLE: Re-add item_type to create_memory_object_stream
DESCRIPTION: The 'item_type' argument has been re-added to create_memory_object_stream(). While it raises a deprecation warning and has no effect on static types, it restores previous functionality.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_99

LANGUAGE: Python
CODE:
```
from anyio import create_memory_object_stream

# Example usage (will raise DeprecationWarning)
# sender, receiver = create_memory_object_stream(item_type=int)
```

--------------------------------

TITLE: Fix Process Pruning Leading to Memory Issues in anyio.to_process
DESCRIPTION: Resolves a memory consumption issue in `anyio.to_process` where pruned idle processes were incorrectly marked as unusable, leading to increased memory usage.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_95

LANGUAGE: python
CODE:
```
Fixed processes spawned by ``anyio.to_process()`` being "lost" as unusable to the
  process pool when processes that have idled over 5 minutes are pruned at part of the
  ``to_process.run_sync()`` call, leading to increased memory consumption
  (PR by Anael Gorfinkel)
```

--------------------------------

TITLE: Fix TLSStream BrokenResourceError on Peer Close
DESCRIPTION: Corrects an issue in ``TLSStream`` where ``BrokenResourceError`` was raised instead of ``EndOfStream`` when the peer abruptly closed the connection during data reception with ``standard_compatible=False``.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_128

LANGUAGE: Python
CODE:
```
Fixed ``BrokenResourceError`` instead of ``EndOfStream`` being raised in ``TLSStream``
  when the peer abruptly closes the connection while ``TLSStream`` is receiving data
  with ``standard_compatible=False`` set
```

--------------------------------

TITLE: Drop Python 3.8 support
DESCRIPTION: Removes support for Python 3.8, as certain issues, like cancel message support, cannot be resolved without it.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_37

LANGUAGE: Python
CODE:
```
Dropped support for Python 3.8
  (as `#698 <https://github.com/agronholm/anyio/issues/698>`_ cannot be resolved
  without cancel message support)
```

--------------------------------

TITLE: Run Synchronous Function in Worker Process (Python)
DESCRIPTION: Executes a CPU-intensive synchronous function in a separate worker process to bypass Python's Global Interpreter Lock (GIL). This is crucial for true parallelism on multi-core systems.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/subprocesses.rst#_snippet_3

LANGUAGE: Python
CODE:
```
import time

from anyio import run, to_process


def cpu_intensive_function(arg1, arg2):
    time.sleep(1)
    return arg1 + arg2

async def main():
    result = await to_process.run_sync(cpu_intensive_function, 'Hello, ', 'world!')
    print(result)

# This check is important when the application uses to_process.run_sync()
if __name__ == '__main__':
    run(main)
```

--------------------------------

TITLE: Check for Cancellation in Worker Threads
DESCRIPTION: Illustrates how to voluntarily check for cancellation within a synchronous function running in a worker thread. If the host task's scope has been cancelled, `from_thread.check_cancelled()` raises a cancellation exception.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_9

LANGUAGE: Python
CODE:
```
import time

from anyio import to_thread, from_thread, move_on_after

def sync_function():
    while True:
        from_thread.check_cancelled()
        print("Not cancelled yet")
        time.sleep(1)

async def foo():
    with move_on_after(3):
        await to_thread.run_sync(sync_function)
```

--------------------------------

TITLE: Asyncio Test Runner Exception Capture
DESCRIPTION: Modifies the asyncio test runner to capture unhandled exceptions from asynchronous callbacks and unbound native tasks, raising them after test completion for better error reporting.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_174

LANGUAGE: Python
CODE:
```
asyncio test runner
```

--------------------------------

TITLE: Fix Incorrect Call Order in Socket Close
DESCRIPTION: Corrects the incorrect call order in socket close notifications, particularly affecting Windows. This ensures that sockets are closed in the proper sequence, preventing potential resource leaks or errors.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_256

LANGUAGE: Python
CODE:
```
# This is an internal implementation detail fix related to socket handling.
```

--------------------------------

TITLE: AnyIO Task Introspection
DESCRIPTION: Introduces the ability to introspect running tasks within the AnyIO framework using `anyio.get_running_tasks()`. This allows developers to monitor and manage concurrent operations more effectively.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_266

LANGUAGE: Python
CODE:
```
import anyio

async def monitor_tasks():
    running_tasks = anyio.get_running_tasks()
    print(f"Currently running tasks: {running_tasks}")
```

--------------------------------

TITLE: Update Cancellation Semantics (AnyIO 4.0.0)
DESCRIPTION: Version 4.0.0 of AnyIO introduced significant changes to cancellation semantics. Exceptions raised from task groups are now nested within an ExceptionGroup, and task group exit behavior has been refined to ensure yielding points and proper handling of deferred cancellations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_77

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** Changes to cancellation semantics:

  - Any exceptions raising out of a task groups are now nested inside an
    ``ExceptionGroup`` (or ``BaseExceptionGroup`` if one or more ``BaseException`` were
    included)
  - Fixed task group not raising a cancellation exception on asyncio at exit if no child
    tasks were spawned and an outer cancellation scope had been cancelled before
  - Ensured that exiting a ``TaskGroup`` always hits a yield point, regardless of
    whether there are running child tasks to be waited on
  - On asyncio, cancel scopes will defer cancelling tasks that are scheduled to resume
    with a finished future
  - On asyncio and Python 3.9/3.10, cancel scopes now only suppress cancellation
    exceptions if the cancel message matches the scope
  - Task groups on all backends now raise a single cancellation exception when an outer
    cancel scope is cancelled, and no exceptions other than cancellation exceptions are
    raised in the group
```

--------------------------------

TITLE: Replace AnyIO ExceptionGroup with PEP 654 (AnyIO 4.0.0)
DESCRIPTION: In version 4.0.0, AnyIO replaced its custom ExceptionGroup class with the standard PEP 654 BaseExceptionGroup and ExceptionGroup. This change standardizes exception handling for grouped exceptions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_76

LANGUAGE: python
CODE:
```
**BACKWARDS INCOMPATIBLE** Replaced AnyIO's own ``ExceptionGroup`` class with the PEP
  654 ``BaseExceptionGroup`` and ``ExceptionGroup``
```

--------------------------------

TITLE: Rename BrokenWorkerIntepreter to BrokenWorkerInterpreter
DESCRIPTION: Renames the `BrokenWorkerIntepreter` exception to `BrokenWorkerInterpreter` for better clarity and correctness. The old name is retained as a deprecated alias for backward compatibility.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_11

LANGUAGE: Python
CODE:
```
import anyio

# try:
#     # code that might raise the exception
#     pass
# except anyio.BrokenWorkerInterpreter as e:
#     print(f"Caught expected exception: {e}")
# except anyio.BrokenWorkerIntepreter as e: # Deprecated alias
#     print(f"Caught deprecated exception: {e}")

```

--------------------------------

TITLE: Fix current_effective_deadline() returning -inf on asyncio
DESCRIPTION: Corrects current_effective_deadline() on asyncio to return -inf when the active cancel scope has been cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_109

LANGUAGE: Python
CODE:
```
from anyio import current_effective_deadline, CancelScope

# async with CancelScope() as scope:
#     scope.cancel()
#     deadline = current_effective_deadline()
#     # deadline should now be -inf
```

--------------------------------

TITLE: Add Parent ID to TaskInfo
DESCRIPTION: Adds the `parent_id` attribute to the `anyio.TaskInfo` object. This allows for tracking the hierarchical relationship between tasks, making it easier to understand task dependencies and execution flow.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_233

LANGUAGE: Python
CODE:
```
import anyio

async def get_task_hierarchy():
    task_infos = await anyio.get_all_tasks()
    for task_info in task_infos:
        print(f"Task ID: {task_info.id}, Parent ID: {task_info.parent_id}")
```

--------------------------------

TITLE: Add CancelScope.cancelled_caught Property (AnyIO)
DESCRIPTION: Introduces the `CancelScope.cancelled_caught` property, which allows users to determine if a specific cancel scope has suppressed a cancellation exception.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_89

LANGUAGE: python
CODE:
```
Added the ``CancelScope.cancelled_caught`` property which tells users if the cancel
  scope suppressed a cancellation exception
```

--------------------------------

TITLE: Bind Unconnected UDP Sockets (Asyncio + Windows)
DESCRIPTION: Modifies unconnected UDP sockets to always be bound to a local port on the 'any' interface, preventing errors specifically on asyncio with Windows.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_130

LANGUAGE: Python
CODE:
```
Changed unconnected UDP sockets to be always bound to a local port (on "any"
  interface) to avoid errors on asyncio + Windows
```

--------------------------------

TITLE: Fix Lock Acquisition Twice on Asyncio
DESCRIPTION: Addresses an issue where acquiring a lock twice within the same task on asyncio would cause a hang instead of raising a RuntimeError.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_43

LANGUAGE: Python
CODE:
```
import anyio

async def example():
    lock = anyio.Lock()
    async with lock:
        # Acquire lock again - this should now raise RuntimeError instead of hanging
        async with lock:
            pass
```

--------------------------------

TITLE: Parameter Renaming in AnyIO
DESCRIPTION: This change in AnyIO involves renaming the 'max_size' parameter to 'max_bytes' across all occurrences to ensure consistent naming conventions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_210

LANGUAGE: Python
CODE:
```
Renamed the max_size parameter to max_bytes wherever it occurred
```

--------------------------------

TITLE: Fix AssertionError in connect_tcp()
DESCRIPTION: Resolves an `AssertionError` that could occur in `connect_tcp()` when multiple connection attempts succeeded simultaneously. This ensures the function handles concurrent successful connections robustly.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_243

LANGUAGE: Python
CODE:
```
import anyio

async def connect_robustly(host, port):
    async with await anyio.connect_tcp(host, port) as stream:
        # Connection established successfully even with concurrent attempts
```

--------------------------------

TITLE: Fix get_running_tasks() Returning Other Loop Tasks
DESCRIPTION: Resolves an issue where `get_running_tasks()` incorrectly returned tasks from other event loops in the asyncio backend. This ensures that the function only returns tasks belonging to the current event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_264

LANGUAGE: Python
CODE:
```
import anyio

async def get_current_loop_tasks():
    tasks = await anyio.get_all_tasks()
    # tasks should now only contain tasks from the current loop
```

--------------------------------

TITLE: Fix TaskInfo.has_pending_cancellation() on Asyncio
DESCRIPTION: Ensures that TaskInfo.has_pending_cancellation() correctly respects shielded scopes on asyncio, preventing incorrect status reporting.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_54

LANGUAGE: Python
CODE:
```
import anyio

async def shielded_task():
    async with anyio.CancelScope(shield=True):
        await anyio.sleep(100)

async def check_cancellation_status():
    task = await anyio.create_task(shielded_task())
    await anyio.sleep(0.1) # Give the task a moment to start

    task_info = task.get_info()
    # This should now correctly return False because the scope is shielded
    print(f"Has pending cancellation (shielded): {task_info.has_pending_cancellation()}")

    # Cancel the task explicitly
    task.cancel()
    await anyio.sleep(0.1)
    task_info = task.get_info()
    print(f"Has pending cancellation (after cancel): {task_info.has_pending_cancellation()}")

# anyio.run(check_cancellation_status)
```

--------------------------------

TITLE: Exclusive Lock and Condition Release
DESCRIPTION: Enforces that `Lock` and `Condition` can only be released by the task that acquired them. This ensures consistent behavior across different backends, improving robustness.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_169

LANGUAGE: Python
CODE:
```
anyio.Lock.release()
```

LANGUAGE: Python
CODE:
```
anyio.Condition.release()
```

--------------------------------

TITLE: Update CancelScope to Consider Cancellation Count
DESCRIPTION: The `CancelScope` in AnyIO now also considers the cancellation count in addition to other factors when managing cancellation, providing more nuanced control over cancellation propagation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_97

LANGUAGE: python
CODE:
```
Changed ``CancelScope`` to also consider the cancellation count (in addition to the
```

--------------------------------

TITLE: Fix Cancellation Propagation from Nested Task Groups
DESCRIPTION: Ensures that cancellation correctly propagates from nested task groups. This fix guarantees that if a task in an inner task group is cancelled, the cancellation signal is passed up to the outer task groups as expected.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_263

LANGUAGE: Python
CODE:
```
import anyio

async def nested_task_groups():
    async with anyio.create_task_group() as tg1:
        async with anyio.create_task_group() as tg2:
            await tg2.spawn(some_task)
        await tg1.cancel_scope.cancel() # Cancellation should propagate to tg2
```

--------------------------------

TITLE: Asyncio Thread Pooling
DESCRIPTION: Enables thread pooling on asyncio using `run_sync_in_worker_thread()`, improving performance for synchronous operations executed within the asyncio event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_177

LANGUAGE: Python
CODE:
```
anyio.run_sync_in_worker_thread()
```

--------------------------------

TITLE: Fix run_sync_in_worker_thread UnboundLocalError
DESCRIPTION: Resolves `UnboundLocalError` in `run_sync_in_worker_thread()` on asyncio when cancelled, ensuring proper exception handling during cancellation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_190

LANGUAGE: Python
CODE:
```
anyio.run_sync_in_worker_thread()
```

--------------------------------

TITLE: Fix Trio Test Runner BaseException Errors
DESCRIPTION: Corrects the Trio test runner to prevent unwarranted test errors when encountering `BaseException`, ensuring more accurate test results.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_185

LANGUAGE: Python
CODE:
```
Trio test runner
```

--------------------------------

TITLE: Fix KeyboardInterrupt Hanging Asyncio Pytest Runner
DESCRIPTION: Resolves an issue where pressing Ctrl+C (KeyboardInterrupt) would cause the asyncio pytest runner to hang.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_58

LANGUAGE: Python
CODE:
```
import anyio
import pytest

async def long_running_task():
    while True:
        await anyio.sleep(1)

# To test this, run pytest with the asyncio plugin:
# pytest --asyncio-mode=auto your_test_file.py

# Inside your test file:
# async def test_long_task_interrupt():
#     async with anyio.create_task_group() as tg:
#         await tg.spawn(long_running_task)
#         # During test execution, press Ctrl+C.
#         # The test should terminate cleanly instead of hanging.
#         await anyio.sleep(10) # Keep the task group alive for interruption

```

--------------------------------

TITLE: Fix Async Generator Await AttributeError
DESCRIPTION: Addresses an `AttributeError: 'async_generator_asend' object has no attribute 'cr_await'` on asyncio, improving the stability of asynchronous generators.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_194

LANGUAGE: Python
CODE:
```
async_generator_asend cr_await
```

--------------------------------

TITLE: Fix fail_after() TimeoutError on Cancellation (AnyIO)
DESCRIPTION: Corrects an issue where `fail_after()` incorrectly raised a `TimeoutError` when the associated cancel scope was cancelled before its deadline was reached.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_90

LANGUAGE: python
CODE:
```
Fixed ``fail_after()`` raising an unwarranted ``TimeoutError`` when the cancel scope
  was cancelled before reaching its deadline
```

--------------------------------

TITLE: Fix asyncio task groups yielding control at exit
DESCRIPTION: Ensures that asyncio task groups yield control to the event loop upon exit, even if there are no child tasks to wait for.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_40

LANGUAGE: Python
CODE:
```
Fixed asyncio task groups not yielding control to the event loop at exit if there were
  no child tasks to wait on
```

--------------------------------

TITLE: Fix TypeError in get_current_task() with custom Task factory
DESCRIPTION: Resolves a TypeError that occurred in get_current_task() on asyncio when a custom Task factory was used.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_116

LANGUAGE: Python
CODE:
```
from anyio.from_thread import get_current_task

# The function now correctly handles custom Task implementations.
```

--------------------------------

TITLE: Unreliable Object Stream Interfaces
DESCRIPTION: Defines interfaces for unreliable object streams, where data might be lost or arrive out of order. These are typically used for datagram-based protocols.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_43

LANGUAGE: Python
CODE:
```
async def process_unreliable_stream(stream: anyio.abc.UnreliableObjectStream):
    await stream.send(data)
    received_data = await stream.receive()
```

--------------------------------

TITLE: Use nonlocal for Local Variables in Exception Handlers
DESCRIPTION: Illustrates how to modify local variables within exception handler functions in AnyIO. The `nonlocal` keyword is used to declare that a variable refers to a variable in the nearest enclosing scope that is not global.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/tasks.rst#_snippet_5

LANGUAGE: Python
CODE:
```
import anyio
from anyio import create_task_group, catch

def handle_keyerror(excgroup: ExceptionGroup) -> None:
    # handle each KeyError
    pass

async def some_task():
    pass

async def another_task():
    pass

async def yourfunc():
    somevariable: str | None = None

    def handle_valueerror(exc):
        nonlocal somevariable
        somevariable = 'whatever'

    with catch({
        ValueError: handle_valueerror,
        KeyError: handle_keyerror
    }):
        async with create_task_group() as tg:
            tg.start_soon(some_task)
            tg.start_soon(another_task)

    print(f"{somevariable=}")
```

--------------------------------

TITLE: Run Synchronous Function in Worker Thread (AnyIO)
DESCRIPTION: Demonstrates how to execute a synchronous function, like `time.sleep`, in a separate worker thread using `anyio.to_thread.run_sync`. This prevents blocking the main event loop. The `cancellable=True` option can be used to allow cancellation of the task while waiting for the thread.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_0

LANGUAGE: Python
CODE:
```
import time

from anyio import to_thread, run


async def main():
    await to_thread.run_sync(time.sleep, 5)

run(main)
```

--------------------------------

TITLE: Fix MemoryObjectSendStream Send BrokenResourceError
DESCRIPTION: Fixes `MemoryObjectSendStream.send()` raising `BrokenResourceError` when the last receiver is closed immediately after receiving an item, ensuring correct resource management.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_192

LANGUAGE: Python
CODE:
```
anyio.MemoryObjectSendStream.send()
```

--------------------------------

TITLE: Adjust Default Maximum Worker Threads
DESCRIPTION: Shows how to modify the default maximum number of worker threads used by AnyIO's thread limiter. This is done by accessing and setting the `total_tokens` attribute of the current default thread limiter.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/threads.rst#_snippet_8

LANGUAGE: Python
CODE:
```
from anyio import to_thread

async def foo():
    # Set the maximum number of worker threads to 60
    to_thread.current_default_thread_limiter().total_tokens = 60
```

--------------------------------

TITLE: Fix Asyncio Socket Stream Half-Close
DESCRIPTION: Fixes a bug in the asyncio socket stream where receiving a half-close from the peer would shut down the entire connection, ensuring proper handling of connection states.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_181

LANGUAGE: Python
CODE:
```
asyncio socket stream
```

--------------------------------

TITLE: Fix compatibility of anyio.to_interpreter with Python 3.14.0b2
DESCRIPTION: Resolves compatibility issues with the `anyio.to_interpreter` function when used with Python 3.14.0b2, ensuring correct behavior in inter-interpreter communication.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_8

LANGUAGE: Python
CODE:
```
import anyio

# Example usage:
# async def run_in_other_interpreter():
#     await anyio.to_interpreter(some_function, interpreter=...)

```

--------------------------------

TITLE: Fix RuntimeError in to_thread.run_sync() on asyncio
DESCRIPTION: Addresses a RuntimeError occurring in `to_thread.run_sync()` when using asyncio without a root task. The fix binds worker thread lifetimes to the host task of the cancel scope hierarchy or the current task if no cancel scope is active.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_156

LANGUAGE: Python
CODE:
```
import anyio

async def main():
    # Example usage that might have caused the error
    await anyio.to_thread.run_sync(lambda: None)

# In a scenario where a root task might not be obvious:
# anyio.run(main)
```

--------------------------------

TITLE: Add send_eof() to AnyIO Streams
DESCRIPTION: The send_eof() method has been introduced to all bidirectional streams in AnyIO, enabling the explicit signaling of the end of a transmission.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_212

LANGUAGE: Python
CODE:
```
The send_eof() method was added to all (bidirectional) streams
```

--------------------------------

TITLE: Add a Typed Attribute
DESCRIPTION: Adds a typed attribute to an object, allowing for type-safe attribute access. This is useful for extending objects with custom metadata.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_9

LANGUAGE: Python
CODE:
```
anyio.typed_attribute(name, type)
```

--------------------------------

TITLE: Fix to_thread.run_sync() Prematurely Inactive Thread
DESCRIPTION: Resolves a bug where ``to_thread.run_sync()`` would prematurely mark a worker thread as inactive if a task awaiting its result was cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_147

LANGUAGE: Python
CODE:
```
Fixed ``to_thread.run_sync()`` prematurely marking a worker thread inactive when a
  task await on the result is cancelled
```

--------------------------------

TITLE: Fix sending large buffers via UNIX stream sockets on asyncio
DESCRIPTION: Corrects an issue related to sending large buffers over UNIX stream sockets when using the asyncio backend.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_101

LANGUAGE: Python
CODE:
```
from anyio.streams.uds import UnixStreamSocket

# The fix likely involves adjustments in how data is buffered or sent
# over the socket connection.
```

--------------------------------

TITLE: Fix Native Task Names on Asyncio
DESCRIPTION: Fixes native task names not being set on asyncio for Python 3.8+, ensuring tasks are correctly identified in debugging and profiling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_182

LANGUAGE: Python
CODE:
```
asyncio native task names
```

--------------------------------

TITLE: Fix Level-Triggered Cancellation Resume (Asyncio)
DESCRIPTION: Resolves a cancellation problem in asyncio where level-triggered cancellation for all parent cancel scopes would not resume after exiting a shielded nested scope. This issue is tracked under issue #370.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_131

LANGUAGE: Python
CODE:
```
Fixed cancellation problem on asyncio where level-triggered cancellation for **all**
  parent cancel scopes would not resume after exiting a shielded nested scope
  (`#370 <https://github.com/agronholm/anyio/issues/370>`_)
```

--------------------------------

TITLE: Fix TLSStream Send EOF Error
DESCRIPTION: Corrects `TLSStream.send_eof()` to raise `NotImplementedError` instead of `ValueError` when the operation is not supported, providing clearer error feedback.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_183

LANGUAGE: Python
CODE:
```
anyio.TLSStream.send_eof()
```

--------------------------------

TITLE: AnyIO Recursive Traceback Fix
DESCRIPTION: This snippet details a bug fix in AnyIO 2.0.0 for asyncio and curio backends. It resolves an issue that caused recursive tracebacks when an exception from an inner task group was re-raised in an outer task group.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_207

LANGUAGE: Python
CODE:
```
Fixed recursive tracebacks when a single exception from an inner task group is reraised in an outer task group
```

--------------------------------

TITLE: Run Synchronous Function in a Worker Thread
DESCRIPTION: Executes a synchronous function in a separate worker thread, preventing it from blocking the main asynchronous event loop. Useful for I/O-bound or CPU-bound synchronous code.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_19

LANGUAGE: Python
CODE:
```
result = await anyio.to_thread.run_sync(sync_function, arg1, kwarg1=value)
```

--------------------------------

TITLE: Change Asyncio Task Groups Cancellation Handling
DESCRIPTION: Modifies how asyncio task groups handle cancellations. If only ``CancelledErrors`` are raised by host and child tasks, a single ``CancelledError`` is now raised instead of an ``ExceptionGroup``, allowing asyncio to ignore it during propagation.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_154

LANGUAGE: Python
CODE:
```
Changed asyncio task groups so that if the host and child tasks have only raised
  ``CancelledErrors``, just one ``CancelledError`` will now be raised instead of an
  ``ExceptionGroup``, allowing asyncio to ignore it when it propagates out of the task
```

--------------------------------

TITLE: Fix CancelScope task uncancellation on Python 3.11
DESCRIPTION: Implements a fix for CancelScope to properly handle asyncio task uncancellation on Python 3.11.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_111

LANGUAGE: Python
CODE:
```
from anyio import CancelScope

# This fix ensures that tasks within a CancelScope behave as expected
# regarding cancellation and uncancellation on Python 3.11.
```

--------------------------------

TITLE: Fix Task Cancellation Timing
DESCRIPTION: Ensures that task cancellation occurs immediately on asyncio and curio when a cancel scope is entered after its deadline has already passed. This prevents delays in cancellation processing.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_259

LANGUAGE: Python
CODE:
```
import anyio
import time

async def cancel_immediately_after_deadline():
    await anyio.sleep(1) # Simulate time passing
    async with anyio.open_cancel_scope(deadline=0):
        # Cancellation should happen immediately here
```

--------------------------------

TITLE: Sleep Until a Specific Time in AnyIO
DESCRIPTION: Suspends the current asynchronous task until a specified deadline (a timestamp) is reached. This is useful for scheduling tasks to run at a particular time.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_5

LANGUAGE: Python
CODE:
```
await anyio.sleep_until(deadline_timestamp)
```

--------------------------------

TITLE: Asyncio CancelScope Exit Error
DESCRIPTION: Changes the asyncio `CancelScope` to raise a `RuntimeError` if a cancel scope is exited before it was entered, preventing incorrect scope management.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_173

LANGUAGE: Python
CODE:
```
asyncio.CancelScope
```

--------------------------------

TITLE: Semaphore Max Value Property
DESCRIPTION: Adds the `max_value` property to `Semaphore`, providing access to the maximum value the semaphore can hold.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_171

LANGUAGE: Python
CODE:
```
anyio.Semaphore.max_value
```

--------------------------------

TITLE: Check for Cancellation from Another Thread
DESCRIPTION: Checks if the current asynchronous operation, called from another thread, has been cancelled. This allows for cooperative cancellation handling.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_27

LANGUAGE: Python
CODE:
```
if anyio.from_thread.check_cancelled():
    raise CancelledError()
```

--------------------------------

TITLE: Fix AssertionError on Subprocess Feed Data After Feed EOF
DESCRIPTION: Corrects an 'AssertionError: feed_data after feed_eof' that occurred on asyncio when a subprocess was closed early before its output could be read.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_53

LANGUAGE: Python
CODE:
```
import anyio

async def run_subprocess_and_feed_early_close():
    try:
        # Start a process that produces output
        process = await anyio.open_process("python", "-c", "import sys; sys.stdout.write('hello\n'); sys.stdout.flush()")

        # Read some output
        output = await process.read(10)
        print(f"Read: {output.decode()}")

        # Close the subprocess early before reading all output
        await process.terminate()
        await process.wait()

        # Attempting to feed data after EOF might have caused the error
        # This scenario is complex to reproduce directly without specific timing

    except anyio.exceptions.ProcessError as e:
        print(f"Process error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# anyio.run(run_subprocess_and_feed_early_close)
```

--------------------------------

TITLE: Fix MemoryObjectReceiveStream Cancellation State on Asyncio
DESCRIPTION: Resolves a bug in `MemoryObjectReceiveStream.receive()` on asyncio where the receiving task could remain in a cancelled state if cancellation occurred after an item was queued but before it was received.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_91

LANGUAGE: python
CODE:
```
Fixed ``MemoryObjectReceiveStream.receive()`` causing the receiving task on asyncio to
  remain in a cancelled state if the operation was cancelled after an item was queued to
  be received by the task (but before the task could actually receive the item)
```

--------------------------------

TITLE: Asyncio Cancel Scope Enforcement
DESCRIPTION: Ensures cancel scopes are properly enforced with native asyncio coroutine functions without explicit AnyIO checkpoints, improving cancellation reliability in asyncio.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_172

LANGUAGE: Python
CODE:
```
asyncio.CancelScope
```

--------------------------------

TITLE: Fix Exception Group Handling with Timed Scopes
DESCRIPTION: Ensures that an exception group containing only cancellation exceptions is correctly swallowed by a timed-out cancel scope on asyncio and curio. This prevents unexpected propagation of cancellation-related exceptions.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_260

LANGUAGE: Python
CODE:
```
import anyio

async def handle_cancellation_exception_group():
    try:
        async with anyio.open_cancel_scope(deadline=1):
            # Simulate raising an exception group with cancellations
            pass
    except anyio.get_cancelled_exc_class():
        # This should be caught by the timed scope
```

--------------------------------

TITLE: Fix Debugger Quit Hanging Pytest Test Session
DESCRIPTION: Resolves a bug where quitting the debugger within a pytest test session, while in an active task group, caused the test to fail instead of exiting the session.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_56

LANGUAGE: Python
CODE:
```
import anyio
import pytest

async def task_that_might_be_debugged():
    await anyio.sleep(10)

# To reproduce: Run pytest with a debugger attached,
# set a breakpoint inside task_that_might_be_debugged,
# and then quit the debugger while the breakpoint is hit.

# Example test function structure:
# async def test_debugger_quit():
#     async with anyio.create_task_group() as tg:
#         await tg.spawn(task_that_might_be_debugged)
#         # Set breakpoint here or within the spawned task
#         await anyio.sleep(1) # Keep task group alive

```

--------------------------------

TITLE: Fix RuntimeError on CancelledError from BlockingPortal Task (Asyncio)
DESCRIPTION: Resolves a ``RuntimeError`` that occurred in asyncio when a ``CancelledError`` was raised from a task spawned via a ``BlockingPortal`. This is related to issue #357.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_134

LANGUAGE: Python
CODE:
```
Fixed ``RuntimeError`` on asyncio when a ``CancelledError`` is raised from a task
  spawned through a ``BlockingPortal``
  (`#357 <https://github.com/agronholm/anyio/issues/357>`_)
```

--------------------------------

TITLE: Fix asyncio cancel scopes not propagating CancelledError
DESCRIPTION: Addresses an issue where cancel scopes on asyncio would not propagate `CancelledError` on exit when the enclosing cancel scope was effectively cancelled.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_39

LANGUAGE: Python
CODE:
```
Fixed cancel scopes on asyncio not propagating ``CancelledError`` on exit when the
  enclosing cancel scope has been effectively cancelled
  (`#698 <https://github.com/agronholm/anyio/issues/698>`_)
```

--------------------------------

TITLE: Fix Task Cancellation Mishandling
DESCRIPTION: Corrects the mishandling of task cancellation while a task is running a worker thread on asyncio and curio backends. This ensures that cancellations are processed correctly even when involving threads.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_253

LANGUAGE: Python
CODE:
```
import anyio

async def task_in_thread():
    # Simulate work in a thread
    pass

async def cancel_task_in_thread():
    async with anyio.create_task_group() as tg:
        await tg.spawn(anyio.run_in_thread, task_in_thread)
        await tg.cancel_scope.cancel()
```

--------------------------------

TITLE: Fix Worker Thread Hang (Asyncio)
DESCRIPTION: Corrects an asyncio bug where, under specific circumstances, a stopping worker thread would continue to accept new assignments, leading to a program hang.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_141

LANGUAGE: Python
CODE:
```
Fixed an asyncio bug where under certain circumstances, a stopping worker thread would
  still accept new assignments, leading to a hang
```

--------------------------------

TITLE: Cancellable Parameter for run_in_thread
DESCRIPTION: Adds a `cancellable` parameter to the `anyio.run_in_thread()` function. When set to `True`, tasks running in threads via this function can be cancelled, allowing for better control over long-running threaded operations.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_226

LANGUAGE: Python
CODE:
```
import anyio

def blocking_io():
    # Simulate a long-running blocking operation
    pass

async def run_cancellable_thread():
    await anyio.run_in_thread(blocking_io, cancellable=True)
```

--------------------------------

TITLE: Remove Unnecessary Wait Cycle in Event.wait() on Asyncio
DESCRIPTION: Optimizes `Event.wait()` on the asyncio backend by removing an unnecessary extra waiting cycle that occurred when the event was not yet set.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_94

LANGUAGE: python
CODE:
```
Removed unnecessary extra waiting cycle in ``Event.wait()`` on asyncio in the case
  where the event was not yet set
```

--------------------------------

TITLE: Fix inconsistent task uncancellation on asyncio
DESCRIPTION: Corrects inconsistent task uncancellation behavior on asyncio when cancel scopes belong to a task group with running child tasks.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_41

LANGUAGE: Python
CODE:
```
Fixed inconsistent task uncancellation with asyncio cancel scopes belonging to a
  task group when said task group has child tasks running
```

--------------------------------

TITLE: AnyIO Byte Stream Closing Behavior
DESCRIPTION: This snippet describes a backwards-incompatible change in AnyIO 2.0.0 for byte streams. Byte streams, including socket streams, now raise `EndOfStream` instead of returning an empty bytes object when the stream is closed by the other end.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_201

LANGUAGE: Python
CODE:
```
Byte streams (including socket streams) now raise `EndOfStream` instead of returning an empty bytes object when the stream has been closed from the other end
```

--------------------------------

TITLE: Fix cancelled cancel scopes on asyncio exit
DESCRIPTION: Corrects behavior where cancelled cancel scopes on asyncio would call `asyncio.Task.uncancel` when propagating a `CancelledError` on exit to a cancelled parent scope.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_34

LANGUAGE: Python
CODE:
```
Fixed cancelled cancel scopes on asyncio calling ``asyncio.Task.uncancel`` when
  propagating a ``CancelledError`` on exit to a cancelled parent scope
  (`#790 <https://github.com/agronholm/anyio/pull/790>`_; PR by @gschaffner)
```

--------------------------------

TITLE: Fix Idle Thread Pruning (Asyncio)
DESCRIPTION: Addresses an issue in asyncio where idle thread pruning could sometimes result in an expired worker thread being assigned a task.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_142

LANGUAGE: Python
CODE:
```
Fixed idle thread pruning on asyncio sometimes causing an expired worker thread to be
  assigned a task
```

--------------------------------

TITLE: Fix Deadlock in Synchronization Primitives (Asyncio)
DESCRIPTION: Addresses a deadlock issue in AnyIO's synchronization primitives when used with asyncio. This occurs when a task acquiring a primitive is cancelled by a native (non-AnyIO) cancellation at a critical moment, causing subsequent tasks to wait indefinitely.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_120

LANGUAGE: Python
CODE:
```
Fixed deadlock in synchronization primitives on asyncio which can happen if a task
  acquiring a primitive is hit with a native (not AnyIO) cancellation with just the
  right timing, leaving the next acquiring task waiting forever
  (`#398 <https://github.com/agronholm/anyio/issues/398>`_)
```

--------------------------------

TITLE: Fix Async Fixture Self in Class-Based Tests
DESCRIPTION: Corrects an issue where the 'self' of an async fixture differed from the 'self' of the test in class-based tests.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_44

LANGUAGE: Python
CODE:
```
import anyio
import pytest

class TestMyClass:
    @pytest.fixture
    async def async_fixture(self):
        return self

    async def test_fixture_self(self, async_fixture):
        assert async_fixture is self
```

--------------------------------

TITLE: Fix asyncio CPU usage in exiting task groups
DESCRIPTION: Corrects a problem causing 100% CPU usage on asyncio when waiting for an exiting task group that is within a cancelled cancel scope.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_38

LANGUAGE: Python
CODE:
```
Fixed 100% CPU use on asyncio while waiting for an exiting task group to finish while
  said task group is within a cancelled cancel scope
  (`#695 <https://github.com/agronholm/anyio/issues/695>`_)
```

--------------------------------

TITLE: Fix Race Condition in Lock and Semaphore (Asyncio)
DESCRIPTION: Resolves a race condition in the ``Lock`` and ``Semaphore`` classes within AnyIO when used with asyncio. This issue occurred when a task waiting to acquire a primitive was cancelled while another task was also waiting for the same primitive.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_123

LANGUAGE: Python
CODE:
```
Fixed race condition in ``Lock`` and ``Semaphore`` classes when a task waiting on
  ``acquire()`` is cancelled while another task is waiting to acquire the same primitive
  (`#387 <https://github.com/agronholm/anyio/issues/387>`_)
```

--------------------------------

TITLE: Fix Trio Event Inheritance
DESCRIPTION: Corrects `Event` objects on the Trio backend to inherit from `anyio.abc.Event`, ensuring consistent interface adherence.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_189

LANGUAGE: Python
CODE:
```
anyio.abc.Event
```

--------------------------------

TITLE: Fix AttributeError on Generator Task Cancellation
DESCRIPTION: Resolves an `AttributeError` that occurred when cancelling generator-based tasks in the asyncio backend. This ensures that cancellation works correctly for all task types.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_240

LANGUAGE: Python
CODE:
```
import anyio

async def generator_task():
    yield

async def cancel_generator_task():
    task = await anyio.create_task_group().spawn(generator_task)
    await task.cancel()
```

--------------------------------

TITLE: Sleep for a Duration in AnyIO
DESCRIPTION: Suspends the current asynchronous task for a specified number of seconds. This is a fundamental operation for yielding control back to the event loop.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_3

LANGUAGE: Python
CODE:
```
await anyio.sleep(1.5)
```

--------------------------------

TITLE: Fix CancelledError Leaking from Task Group
DESCRIPTION: Addresses an issue where `CancelledError` could leak from a task group when contained within an exception group. This fix ensures that cancellation exceptions are handled correctly within task group structures.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_244

LANGUAGE: Python
CODE:
```
import anyio

async def task_with_exception_group():
    async with anyio.create_task_group() as tg:
        await tg.spawn(some_task_that_raises_cancellation)
        # Exception group handling is now more robust
```

--------------------------------

TITLE: Sleep Indefinitely in AnyIO
DESCRIPTION: Suspends the current asynchronous task indefinitely until it is cancelled. This is useful for tasks that should run continuously until explicitly stopped.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/api.rst#_snippet_4

LANGUAGE: Python
CODE:
```
await anyio.sleep_forever()
```

--------------------------------

TITLE: AnyIO Task Group Cancellation Bug Fix
DESCRIPTION: This snippet addresses a bug fixed in AnyIO 2.0.0 for asyncio and curio backends. It resolves an issue where a task group would abandon its subtasks if its own cancel scope was cancelled while waiting for subtasks to finish.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_206

LANGUAGE: Python
CODE:
```
Fixed a bug where a task group would abandon its subtasks if its own cancel scope was cancelled while it was waiting for subtasks to finish
```

--------------------------------

TITLE: Fix CancelledError Leaking from Cancel Scope
DESCRIPTION: Addresses an issue where `CancelledError` could leak from a cancel scope on asyncio if the task had previously received a cancellation exception. This fix ensures proper cancellation propagation and cleanup.

SOURCE: https://github.com/agronholm/anyio/blob/master/docs/versionhistory.rst#_snippet_239

LANGUAGE: Python
CODE:
```
import anyio

async def problematic_operation():
    try:
        async with anyio.open_cancel_scope() as scope:
            # Operation that might be cancelled
            pass
    except anyio.get_cancelled_exc_class():
        # Handle cancellation properly
```
