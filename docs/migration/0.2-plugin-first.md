# Migration Guide: 0.2 Plugin-First

CCProxy 0.2 introduces a plugin-first runtime that replaces the monolithic service wiring from the 0.1 series. This guide walks through the changes you need to make when upgrading an existing deployment or custom integrations to the new extension system.

## What Changed in 0.2
- **Manifests drive discovery** – Every provider and system feature now declares a `PluginManifest` that advertises routes, hooks, middleware, CLI extensions, and configuration schemas.
- **DI container owns lifecycle** – Factories receive a `ServiceContainer` and register dependencies explicitly instead of importing singletons from core modules.
- **Hook-based observability** – Access logging, analytics, and tracing now flow through the hook manager instead of bespoke middleware stacks.
- **Format adapters are declarative** – Request/response conversions are registered with the global format registry and validated during startup.

## Prerequisites
- Upgrade to Python 3.11 or later.
- Run `./Taskfile dev-install` to sync the new dependency graph and pre-commit hooks.
- Ensure your configuration files are tracked in version control before you modify them.

## Step 1 – Enable the Plugin Runtime
1. Verify `enable_plugins = true` is set in `ccproxy.toml` or environment variables.
2. Remove `ENABLED_PLUGINS`/`DISABLED_PLUGINS` bash scripts that patched the legacy loader; use `[plugins]` configuration blocks instead.
3. If you ship custom plugins, add their directories to `[plugin_discovery.directories]`.

## Step 2 – Update Provider Integrations
1. Move adapter code into `ccproxy/plugins/<name>/` and expose a `factory` that inherits from `ProviderPluginFactory`.
2. Implement `create_runtime()` to return a subclass of `ProviderPluginRuntime` that wires adapters, detection services, and token managers through the container.
3. Register routes using `PluginManifest.routes` instead of `FastAPI.include_router()` inside the adapter.
4. Provide manifest metadata (version, description, component type) so `/plugins` and health endpoints remain accurate.

## Step 3 – Declare Hooks and Middleware
1. Replace custom middleware with hook implementations where possible. Hooks receive structured `HookContext` objects and do not block the request pipeline when they fail.
2. If you still need middleware, return `MiddlewareSpec` entries from the manifest so the `MiddlewareManager` can order them consistently.
3. Use `HookEvent.HTTP_REQUEST`/`HTTP_RESPONSE` for analytics instead of tapping directly into streaming handlers.

## Step 4 – Configure Format Chains
1. Annotate route handler functions with `@format_chain([...])` decorators from `ccproxy.services.adapters.chain_validation`.
2. Add adapter factories to the manifest via `format_adapters`.
3. Run `./Taskfile test-unit` to confirm `validate_chains` and `validate_stream_pairs` succeed during startup.

## Step 5 – Update Configuration Files
1. Move provider-specific keys under `[plugins.<name>]` sections.
2. Use nested environment variables (e.g., `PLUGINS__CODex__MODEL_MAPPINGS`) to override settings in production.
3. Replace deprecated `[claude]`/`[codex]` roots with their plugin-scoped equivalents.

## Step 6 – Refresh CLI Commands
1. The CLI now discovers plugin subcommands through `discover_plugin_cli_extensions()`. Ensure your plugin manifest declares CLI entries in `cli_commands`.
2. Regenerate shell completions after upgrading: `ccproxy --show-completion zsh > ~/.zfunc/_ccproxy`.

## Validation Checklist
- `./Taskfile ci` passes (ruff, mypy, pytest) with your custom plugins enabled.
- `uv run mkdocs build` renders docs without missing references.
- `/plugins`, `/health`, and `/plugins/<name>/health` display expected metadata.
- Authentication flows succeed via `ccproxy auth login <provider>` and `ccproxy auth status`.

## Rollback
The 0.1.x runtime remains available on the `release/0.1` branch. Rolling back requires restoring the earlier configuration format and removing plugin manifests. Because persistence schemas changed in 0.2, snapshot your credential stores before downgrading.
