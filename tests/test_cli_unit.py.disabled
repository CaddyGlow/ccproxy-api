"""Unit tests for CLI functions."""

import json
import os
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest
import typer
from typer.testing import CliRunner

from ccproxy._version import __version__
from ccproxy.cli.app import (
    app,
    # get_default_path_hook,
    main,
    permission_tool,
    version_callback,
)
from ccproxy.models.responses import (
    PermissionToolAllowResponse,
    PermissionToolDenyResponse,
)


@pytest.mark.unit
class TestVersionCallback:
    """Test version_callback function."""

    def test_version_callback_false(self):
        """Test version_callback with False value does nothing."""
        # Should not raise any exception
        version_callback(False)

    def test_version_callback_true(self):
        """Test version_callback with True value prints version and exits."""
        with patch("ccproxy.cli.main.get_rich_toolkit") as mock_get_toolkit:
            mock_toolkit = Mock()
            mock_get_toolkit.return_value = mock_toolkit

            with pytest.raises(typer.Exit):
                version_callback(True)

            mock_toolkit.print.assert_called_once_with(
                f"ccproxy {__version__}", tag="version"
            )

    def test_version_callback_with_mock_version(self):
        """Test version_callback with mocked version."""
        with (
            patch("ccproxy.cli.main.__version__", "1.2.3"),
            patch("ccproxy.cli.main.get_rich_toolkit") as mock_get_toolkit,
            pytest.raises(typer.Exit),
        ):
            mock_toolkit = Mock()
            mock_get_toolkit.return_value = mock_toolkit

            version_callback(True)

            mock_toolkit.print.assert_called_once_with("ccproxy 1.2.3", tag="version")


# @pytest.mark.unit
# class TestGetDefaultPathHook:
#     """Test get_default_path_hook function."""
#
#     @patch("ccproxy.cli.main.get_package_dir")
#     def test_get_default_path_hook_file_exists(self, mock_get_package_dir):
#         """Test get_default_path_hook when file exists."""
#         mock_package_dir = Path("/mock/package")
#         mock_get_package_dir.return_value = mock_package_dir
#
#         expected_path = mock_package_dir / "ccproxy" / "main.py"
#
#         with patch.object(Path, "is_file", return_value=True):
#             result = get_default_path_hook()
#             assert result == expected_path
#
#     @patch("ccproxy.cli.main.get_package_dir")
#     def test_get_default_path_hook_file_not_exists(self, mock_get_package_dir):
#         """Test get_default_path_hook when file doesn't exist."""
#         mock_package_dir = Path("/mock/package")
#         mock_get_package_dir.return_value = mock_package_dir
#
#         with patch.object(Path, "is_file", return_value=False):
#             with pytest.raises(FileNotFoundError) as exc_info:
#                 get_default_path_hook()
#
#             assert "Could not find a default file to run" in str(exc_info.value)
#
#     @patch("ccproxy.cli.main.get_package_dir")
#     def test_get_default_path_hook_path_construction(self, mock_get_package_dir):
#         """Test get_default_path_hook constructs correct path."""
#         mock_package_dir = Path("/test/path")
#         mock_get_package_dir.return_value = mock_package_dir
#
#         with patch.object(Path, "is_file", return_value=True) as mock_is_file:
#             result = get_default_path_hook()
#
#             # Check that the correct path was checked
#             expected_path = mock_package_dir / "ccproxy" / "main.py"
#             mock_is_file.assert_called_once()
#             assert result == expected_path


@pytest.mark.unit
class TestMainFunction:
    """Test main function (app callback)."""

    def test_main_function_exists(self):
        """Test that main function exists and is callable."""
        assert callable(main)

    def test_main_function_with_version_false(self):
        """Test main function with version=False."""
        # Should not raise any exception
        with patch("typer.Context") as mock_ctx:
            mock_ctx.invoked_subcommand = "api"
            main(mock_ctx, version=False)

    def test_main_function_with_version_true(self):
        """Test main function with version=True."""
        # The version callback is handled eagerly by typer, so we just test
        # that the main function doesn't raise an exception when called directly
        with patch("typer.Context") as mock_ctx:
            mock_ctx.invoked_subcommand = "api"
            main(mock_ctx, version=True)

    def test_main_function_signature(self):
        """Test main function has correct signature."""
        import inspect

        sig = inspect.signature(main)

        # Check that version parameter exists
        assert "version" in sig.parameters
        param = sig.parameters["version"]
        assert param.annotation is bool
        assert param.default is not inspect.Parameter.empty


@pytest.mark.unit
class TestTyperAppConfiguration:
    """Test Typer app configuration."""

    def test_app_is_typer_instance(self):
        """Test that app is a Typer instance."""
        assert isinstance(app, typer.Typer)

    def test_app_configuration(self):
        """Test app configuration options."""
        # Test that the app has the expected configuration
        # Note: Typer doesn't expose these attributes directly,
        # so we test indirectly through behavior
        assert hasattr(app, "callback")
        assert hasattr(app, "command")

    def test_app_has_callback(self):
        """Test that app has a callback (main function)."""
        # The main function should be registered as a callback
        assert app.callback is not None

    def test_app_commands_registration(self):
        """Test that commands are properly registered."""
        # Check that the app has registered commands
        # This is indirect testing since Typer doesn't expose command list easily
        assert hasattr(app, "registered_commands")


@pytest.mark.unit
class TestTyperOptions:
    """Test Typer option configurations."""

    def test_version_option_configuration(self):
        """Test version option is configured correctly."""
        import inspect

        sig = inspect.signature(main)
        version_param = sig.parameters.get("version")

        assert version_param is not None
        assert version_param.annotation is bool

        # Check that it has a default value (from typer.Option)
        assert version_param.default is not inspect.Parameter.empty

    def test_version_option_eager_and_callback(self):
        """Test version option has eager=True and callback set."""
        # The version callback is handled eagerly by typer's option system
        # We test this indirectly by verifying the callback function works
        with patch("ccproxy.cli.main.get_rich_toolkit") as mock_get_toolkit:
            mock_toolkit = Mock()
            mock_get_toolkit.return_value = mock_toolkit

            with pytest.raises(typer.Exit):
                version_callback(True)

            mock_toolkit.print.assert_called_once()


@pytest.mark.unit
class TestHelpText:
    """Test help text and documentation."""

    def test_main_function_docstring(self):
        """Test main function has proper docstring."""
        assert main.__doc__ is not None
        assert "Claude Code Proxy API Server" in main.__doc__
        assert "Anthropic" in main.__doc__

    def test_version_callback_docstring(self):
        """Test version_callback has proper docstring."""
        assert version_callback.__doc__ is not None
        assert "Print version and exit" in version_callback.__doc__

    def test_get_default_path_hook_docstring(self):
        """Test get_default_path_hook has proper docstring."""
        # This function doesn't have a docstring in the current implementation
        # This test documents the current state
        pass


@pytest.mark.unit
class TestErrorHandling:
    """Test error handling in CLI functions."""

    def test_version_callback_type_error(self):
        """Test version_callback with wrong type."""
        # This should work due to Python's truthiness
        with patch("ccproxy.cli.main.get_rich_toolkit") as mock_get_toolkit:
            mock_toolkit = Mock()
            mock_get_toolkit.return_value = mock_toolkit

            with pytest.raises(typer.Exit):
                version_callback(True)  # Use bool instead of string

            mock_toolkit.print.assert_called_once()

    # def test_get_default_path_hook_exception_message(self):
    #     """Test get_default_path_hook exception message is descriptive."""
    #     with patch(
    #         "ccproxy.cli.main.get_package_dir"
    #     ) as mock_get_package_dir:
    #         mock_get_package_dir.return_value = Path("/mock/path")
    #
    #         with patch.object(Path, "is_file", return_value=False):
    #             with pytest.raises(FileNotFoundError) as exc_info:
    #                 get_default_path_hook()
    #
    #             error_msg = str(exc_info.value)
    #             assert "Could not find a default file to run" in error_msg
    #             assert "please provide an explicit path" in error_msg


@pytest.mark.unit
class TestConfigCommand:
    """Test config command function."""

    @patch("ccproxy.cli.commands.config.commands.get_settings")
    @patch("rich.console.Console")
    def test_config_command_success(self, mock_console_class, mock_get_settings):
        """Test config command displays settings successfully."""
        from ccproxy.cli.commands.config.commands import config_list

        # Mock settings object with all required attributes
        mock_settings = Mock()
        mock_settings.host = "0.0.0.0"
        mock_settings.port = 8000
        mock_settings.log_level = "INFO"
        mock_settings.claude_cli_path = "/usr/bin/claude"
        mock_settings.workers = 1
        mock_settings.reload = False
        mock_settings.server_url = "http://0.0.0.0:8000"
        mock_settings.auth_token = None
        mock_settings.api_tools_handling = "warning"
        mock_settings.cors_origins = ["*"]
        # Add mock docker settings
        mock_docker_settings = Mock()
        mock_docker_settings.docker_image = "claude-code-proxy"
        mock_docker_settings.docker_home_directory = None
        mock_docker_settings.docker_workspace_directory = None
        mock_docker_settings.docker_volumes = []
        mock_docker_settings.docker_environment = {}
        mock_docker_settings.docker_additional_args = []
        mock_docker_settings.user_mapping_enabled = True
        mock_docker_settings.user_uid = 1000
        mock_docker_settings.user_gid = 100
        mock_settings.docker_settings = mock_docker_settings

        # Add mock claude_code_options
        mock_claude_code_options = Mock()
        mock_claude_code_options.model = None
        mock_claude_code_options.max_thinking_tokens = 8000
        mock_claude_code_options.max_turns = None
        mock_claude_code_options.cwd = None
        mock_claude_code_options.system_prompt = None
        mock_claude_code_options.append_system_prompt = None
        mock_claude_code_options.permission_mode = None
        mock_claude_code_options.permission_prompt_tool_name = None
        mock_claude_code_options.continue_conversation = False
        mock_claude_code_options.resume = None
        mock_claude_code_options.allowed_tools = []
        mock_claude_code_options.disallowed_tools = []
        mock_claude_code_options.mcp_servers = []
        mock_claude_code_options.mcp_tools = []
        mock_settings.claude_code_options = mock_claude_code_options

        mock_get_settings.return_value = mock_settings

        # Mock console instance
        mock_console = Mock()
        mock_console_class.return_value = mock_console

        # Call config command - should not raise exceptions
        config_list()

        # Verify settings were fetched
        mock_get_settings.assert_called_once()

        # Verify console was used for output (real console is used, so we just check that no exception was raised)
        # The config function completed successfully if we reach this point

    @patch("ccproxy.cli.commands.config.commands.get_settings")
    @patch("rich.console.Console")
    def test_config_command_with_none_claude_path(
        self, mock_console_class, mock_get_settings
    ):
        """Test config command when claude_cli_path is None."""
        from ccproxy.cli.commands.config.commands import config_list

        # Mock settings object with None claude_cli_path and all required attributes
        mock_settings = Mock()
        mock_settings.host = "localhost"
        mock_settings.port = 3000
        mock_settings.log_level = "DEBUG"
        mock_settings.claude_cli_path = None
        mock_settings.workers = 2
        mock_settings.reload = True
        mock_settings.server_url = "http://localhost:3000"
        mock_settings.auth_token = None
        mock_settings.api_tools_handling = "warning"
        mock_settings.cors_origins = ["*"]
        # Add mock docker settings
        mock_docker_settings = Mock()
        mock_docker_settings.docker_image = "claude-code-proxy"
        mock_docker_settings.docker_home_directory = None
        mock_docker_settings.docker_workspace_directory = None
        mock_docker_settings.docker_volumes = []
        mock_docker_settings.docker_environment = {}
        mock_docker_settings.docker_additional_args = []
        mock_docker_settings.user_mapping_enabled = True
        mock_docker_settings.user_uid = 1000
        mock_docker_settings.user_gid = 100
        mock_settings.docker_settings = mock_docker_settings

        # Add mock claude_code_options
        mock_claude_code_options = Mock()
        mock_claude_code_options.model = None
        mock_claude_code_options.max_thinking_tokens = 8000
        mock_claude_code_options.max_turns = None
        mock_claude_code_options.cwd = None
        mock_claude_code_options.system_prompt = None
        mock_claude_code_options.append_system_prompt = None
        mock_claude_code_options.permission_mode = None
        mock_claude_code_options.permission_prompt_tool_name = None
        mock_claude_code_options.continue_conversation = False
        mock_claude_code_options.resume = None
        mock_claude_code_options.allowed_tools = []
        mock_claude_code_options.disallowed_tools = []
        mock_claude_code_options.mcp_servers = []
        mock_claude_code_options.mcp_tools = []
        mock_settings.claude_code_options = mock_claude_code_options

        mock_get_settings.return_value = mock_settings

        # Mock console instance
        mock_console = Mock()
        mock_console_class.return_value = mock_console

        # Call config command - should not raise exceptions
        config_list()

        # Verify settings were fetched
        mock_get_settings.assert_called_once()

        # Verify console was used for output (real console is used, so we just check that no exception was raised)
        # The config function completed successfully if we reach this point

    @patch("ccproxy.cli.commands.config.commands.get_settings")
    @patch("ccproxy.cli.commands.config.commands.get_rich_toolkit")
    def test_config_command_exception_handling(
        self, mock_get_toolkit, mock_get_settings
    ):
        """Test config command handles exceptions properly."""
        from ccproxy.cli.commands.config.commands import config_list

        # Mock get_settings to raise an exception
        mock_get_settings.side_effect = Exception("Settings error")

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Call config command and expect it to raise typer.Exit
        with pytest.raises(typer.Exit) as exc_info:
            config_list()

        # Verify exit code is 1
        assert exc_info.value.exit_code == 1

        # Verify error message was printed using toolkit
        mock_toolkit.print.assert_called_with(
            "Error loading configuration: Settings error", tag="error"
        )


@pytest.mark.unit
class TestClaudeCommand:
    """Test claude command function."""

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    @patch("os.execvp")
    def test_claude_command_local_execution(
        self, mock_execvp, mock_get_toolkit, mock_load_settings
    ):
        """Test claude command with local execution."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings
        mock_settings = Mock()
        mock_settings.claude_cli_path = "/usr/bin/claude"
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Call claude command
        claude(
            args=["--version"],
            docker=False,
            docker_image=None,
            docker_env=[],
            docker_volume=[],
            docker_arg=[],
            docker_home=None,
            docker_workspace=None,
            user_mapping_enabled=None,
            user_uid=None,
            user_gid=None,
        )

        # Verify settings were fetched
        mock_load_settings.assert_called_once()

        # Verify toolkit was used for output
        mock_toolkit.print.assert_any_call(
            "Executing: /usr/bin/claude --version", tag="claude"
        )
        mock_toolkit.print_line.assert_called()

        # Verify execvp was called with correct arguments
        mock_execvp.assert_called_once_with(
            "/usr/bin/claude", ["/usr/bin/claude", "--version"]
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    def test_claude_command_no_cli_path(self, mock_get_toolkit, mock_load_settings):
        """Test claude command when claude CLI path is not found."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings with no claude_cli_path
        mock_settings = Mock()
        mock_settings.claude_cli_path = None
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Call claude command and expect it to raise typer.Exit
        with pytest.raises(typer.Exit) as exc_info:
            claude(
                args=["--version"],
                docker=False,
                docker_image=None,
                docker_env=[],
                docker_volume=[],
                docker_arg=[],
                docker_home=None,
                docker_workspace=None,
                user_mapping_enabled=None,
                user_uid=None,
                user_gid=None,
            )

        # Verify exit code is 1
        assert exc_info.value.exit_code == 1

        # Verify error messages
        mock_toolkit.print.assert_any_call("Error: Claude CLI not found.", tag="error")
        mock_toolkit.print.assert_any_call(
            "Please install Claude CLI or configure claude_cli_path.", tag="error"
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    @patch("os.execvp")
    def test_claude_command_relative_path_resolution(
        self, mock_execvp, mock_get_toolkit, mock_load_settings
    ):
        """Test claude command resolves relative paths."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings with relative path
        mock_settings = Mock()
        mock_settings.claude_cli_path = "claude"
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        with patch("pathlib.Path.resolve", return_value=Path("/resolved/path/claude")):
            # Call claude command
            claude(
                args=["doctor"],
                docker=False,
                docker_image=None,
                docker_env=[],
                docker_volume=[],
                docker_arg=[],
                docker_home=None,
                docker_workspace=None,
                user_mapping_enabled=None,
                user_uid=None,
                user_gid=None,
            )

        # Verify execvp was called with resolved path
        mock_execvp.assert_called_once_with(
            "/resolved/path/claude", ["/resolved/path/claude", "doctor"]
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude._create_docker_adapter_from_settings")
    @patch("ccproxy.cli.commands.claude.create_docker_adapter")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    @patch("os.execvp")
    def test_claude_command_docker_execution(
        self,
        mock_execvp,
        mock_get_toolkit,
        mock_create_adapter,
        mock_create_from_settings,
        mock_load_settings,
    ):
        """Test claude command with Docker execution."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings
        mock_settings = Mock()
        mock_settings.docker_settings = Mock()
        mock_settings.docker_settings.docker_image = "claude:latest"
        mock_settings.docker_settings.docker_volumes = []
        mock_settings.docker_settings.docker_environment = {}
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Mock Docker adapter factory
        mock_create_from_settings.return_value = (
            "claude:latest",  # image
            [],  # volumes
            {},  # environment
            ["claude", "--version"],  # command
            None,  # user_context
            [],  # additional_args
        )

        # Mock Docker adapter
        mock_adapter = Mock()
        mock_create_adapter.return_value = mock_adapter

        # Call claude command with Docker
        claude(
            args=["--version"],
            docker=True,
            docker_image="custom:latest",
            docker_env=["API_KEY=test"],
            docker_volume=["./data:/data"],
            docker_arg=["--rm"],
            docker_home="/home/user",
            docker_workspace="/workspace",
            user_mapping_enabled=None,
            user_uid=None,
            user_gid=None,
        )

        # Verify Docker adapter factory was called with correct arguments
        mock_create_from_settings.assert_called_once_with(
            mock_settings,
            docker_image="custom:latest",
            docker_env=["API_KEY=test"],
            docker_volume=["./data:/data"],
            docker_arg=["--rm"],
            docker_home="/home/user",
            docker_workspace="/workspace",
            user_mapping_enabled=None,
            user_uid=None,
            user_gid=None,
            command=["claude"],
            cmd_args=["--version"],
        )

        # Verify toolkit was called with Docker command
        mock_toolkit.print.assert_any_call(
            "Executing: docker run ... claude:latest claude --version", tag="docker"
        )
        mock_toolkit.print_line.assert_called()

        # Verify Docker adapter exec_container was called
        mock_adapter.exec_container.assert_called_once_with(
            image="claude:latest",
            volumes=[],
            environment={},
            command=["claude", "--version"],
            user_context=None,
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    @patch("os.execvp")
    def test_claude_command_execvp_os_error(
        self, mock_execvp, mock_get_toolkit, mock_load_settings
    ):
        """Test claude command handles OSError from execvp."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings
        mock_settings = Mock()
        mock_settings.claude_cli_path = "/usr/bin/claude"
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Mock execvp to raise OSError
        mock_execvp.side_effect = OSError("Command not found")

        # Call claude command and expect it to raise typer.Exit
        with pytest.raises(typer.Exit) as exc_info:
            claude(
                args=["--version"],
                docker=False,
                docker_image=None,
                docker_env=[],
                docker_volume=[],
                docker_arg=[],
                docker_home=None,
                docker_workspace=None,
                user_mapping_enabled=None,
                user_uid=None,
                user_gid=None,
            )

        # Verify exit code is 1
        assert exc_info.value.exit_code == 1

        # Verify error message
        mock_toolkit.print.assert_any_call(
            "Failed to execute command: Command not found", tag="error"
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    def test_claude_command_general_exception(
        self, mock_get_toolkit, mock_load_settings
    ):
        """Test claude command handles general exceptions."""
        from ccproxy.cli.commands.claude import claude

        # Mock load_settings to raise an exception
        mock_load_settings.side_effect = Exception("Settings error")

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Call claude command and expect it to raise typer.Exit
        with pytest.raises(typer.Exit) as exc_info:
            claude(
                args=["--version"],
                docker=False,
                docker_image=None,
                docker_env=[],
                docker_volume=[],
                docker_arg=[],
                docker_home=None,
                docker_workspace=None,
                user_mapping_enabled=None,
                user_uid=None,
                user_gid=None,
            )

        # Verify exit code is 1
        assert exc_info.value.exit_code == 1

        # Verify error message
        mock_toolkit.print.assert_any_call(
            "Error executing claude command: Settings error", tag="error"
        )

    @patch("ccproxy.cli.commands.claude.config_manager.load_settings")
    @patch("ccproxy.cli.commands.claude._create_docker_adapter_from_settings")
    @patch("ccproxy.cli.commands.claude.create_docker_adapter")
    @patch("ccproxy.cli.commands.claude.get_rich_toolkit")
    @patch("os.execvp")
    def test_claude_command_docker_with_user_mapping(
        self,
        mock_execvp,
        mock_get_toolkit,
        mock_create_adapter,
        mock_create_from_settings,
        mock_load_settings,
    ):
        """Test claude command with Docker execution and user mapping parameters."""
        from ccproxy.cli.commands.claude import claude

        # Mock settings
        mock_settings = Mock()
        mock_settings.docker_settings = Mock()
        mock_settings.docker_settings.docker_image = "claude:latest"
        mock_settings.docker_settings.docker_volumes = []
        mock_settings.docker_settings.docker_environment = {}
        mock_load_settings.return_value = mock_settings

        # Mock toolkit
        mock_toolkit = Mock()
        mock_get_toolkit.return_value = mock_toolkit

        # Mock Docker adapter factory
        mock_create_from_settings.return_value = (
            "claude:latest",  # image
            [],  # volumes
            {},  # environment
            ["claude", "--version"],  # command
            Mock(uid=1001, gid=1001),  # user_context
            [],  # additional_args
        )

        # Mock Docker adapter
        mock_adapter = Mock()
        mock_create_adapter.return_value = mock_adapter

        # Call claude command with Docker and user mapping
        claude(
            args=["--version"],
            docker=True,
            docker_image=None,
            docker_env=[],
            docker_volume=[],
            docker_arg=[],
            docker_home=None,
            docker_workspace=None,
            user_mapping_enabled=True,
            user_uid=1001,
            user_gid=1001,
        )

        # Verify Docker adapter factory was called with user mapping parameters
        mock_create_from_settings.assert_called_once_with(
            mock_settings,
            docker_image=None,
            docker_env=[],
            docker_volume=[],
            docker_arg=[],
            docker_home=None,
            docker_workspace=None,
            user_mapping_enabled=True,
            user_uid=1001,
            user_gid=1001,
            command=["claude"],
            cmd_args=["--version"],
        )

        # Verify toolkit was called with Docker command
        mock_toolkit.print.assert_any_call(
            "Executing: docker run ... claude:latest claude --version", tag="docker"
        )
        mock_toolkit.print_line.assert_called()

        # Verify Docker adapter exec_container was called
        user_context_mock = mock_create_from_settings.return_value[4]
        mock_adapter.exec_container.assert_called_once_with(
            image="claude:latest",
            volumes=[],
            environment={},
            command=["claude", "--version"],
            user_context=user_context_mock,
        )

    def test_claude_command_docstring(self):
        """Test claude command has proper docstring."""
        from ccproxy.cli.commands.claude import claude

        assert claude.__doc__ is not None
        assert "Execute claude CLI commands directly" in claude.__doc__
        assert "Examples:" in claude.__doc__

    def test_claude_command_parameter_defaults(self):
        """Test claude command has correct parameter defaults."""
        import inspect

        from ccproxy.cli.commands.claude import claude

        sig = inspect.signature(claude)

        # Check args parameter
        args_param = sig.parameters["args"]
        assert args_param.annotation == list[str] | None

        # Check docker parameter
        docker_param = sig.parameters["docker"]
        assert docker_param.annotation is bool

        # Check optional parameters exist
        assert "docker_image" in sig.parameters
        assert "docker_env" in sig.parameters
        assert "docker_volume" in sig.parameters
        assert "docker_arg" in sig.parameters
        assert "docker_home" in sig.parameters
        assert "docker_workspace" in sig.parameters
        assert "user_mapping_enabled" in sig.parameters
        assert "user_uid" in sig.parameters
        assert "user_gid" in sig.parameters


@pytest.mark.unit
class TestModuleImports:
    """Test module imports and dependencies."""

    def test_required_imports_available(self):
        """Test that all required imports are available."""
        # Test that we can import the functions we're testing
        from ccproxy.cli.commands.claude import claude
        from ccproxy.cli.main import (
            app,
            version_callback,
        )

        assert callable(version_callback)
        # assert callable(get_default_path_hook)
        assert callable(claude)
        assert isinstance(app, typer.Typer)

    def test_version_import(self):
        """Test that version can be imported."""
        from ccproxy._version import __version__

        assert isinstance(__version__, str)
        assert len(__version__) > 0

    def test_settings_import(self):
        """Test that settings can be imported."""
        from ccproxy.config.settings import get_settings

        assert callable(get_settings)

    def test_docker_builder_import(self):
        """Test that DockerCommandBuilder can be imported."""
        from ccproxy.utils.docker_builder import DockerCommandBuilder

        assert hasattr(DockerCommandBuilder, "from_settings_and_overrides")

    def test_helper_import(self):
        """Test that helper functions can be imported."""
        from ccproxy.utils.helper import get_package_dir

        assert callable(get_package_dir)


@pytest.mark.unit
class TestPermissionToolCommand:
    """Test permission_tool command function."""

    def _extract_json_from_output(self, output: str) -> Any:
        """Extract JSON from Rich toolkit output."""
        # The Rich toolkit wraps output, so we need to extract just the JSON part
        import re

        # Find the start of JSON
        start_idx = output.find('{"behavior"')
        if start_idx == -1:
            raise ValueError(f"No JSON found in output: {output}")

        # Extract from the start of JSON to the end
        json_part = output[start_idx:]

        # Find the end of the JSON object by counting braces, but be careful about whitespace
        brace_count = 0
        end_idx = 0
        in_string = False
        escape_next = False

        for i, char in enumerate(json_part):
            if escape_next:
                escape_next = False
                continue

            if char == "\\":
                escape_next = True
                continue

            if char == '"' and not escape_next:
                in_string = not in_string
            elif not in_string:
                if char == "{":
                    brace_count += 1
                elif char == "}":
                    brace_count -= 1
                    if brace_count == 0:
                        end_idx = i + 1
                        break

        if end_idx == 0:
            raise ValueError(f"Invalid JSON structure in output: {output}")

        json_str = json_part[:end_idx]
        # Clean up any Rich formatting artifacts but preserve JSON structure
        # Only remove line breaks that are inside the JSON, not spaces within strings
        json_str = re.sub(r"\n\s*", "", json_str)  # Remove line breaks only
        return json.loads(json_str)

    def test_permission_tool_allow_response(self):
        """Test permission_tool command allows safe tool calls."""
        runner = CliRunner()

        # Test with safe tool call
        result = runner.invoke(
            app, ["permission-tool", "bash", '{"command": "ls -la"}']
        )

        assert result.exit_code == 0
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "allow"
        assert "updatedInput" in response_data
        assert response_data["updatedInput"]["command"] == "ls -la"

    def test_permission_tool_deny_dangerous_pattern(self):
        """Test permission_tool command denies dangerous patterns."""
        runner = CliRunner()

        # Test with dangerous command
        result = runner.invoke(
            app, ["permission-tool", "bash", '{"command": "rm -rf /"}']
        )

        assert result.exit_code == 0
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "deny"
        assert "rm -rf" in response_data["message"]

    def test_permission_tool_deny_restricted_tool(self):
        """Test permission_tool command denies restricted tools."""
        runner = CliRunner()

        # Test with restricted tool
        result = runner.invoke(
            app, ["permission-tool", "exec", '{"command": "echo hello"}']
        )

        assert result.exit_code == 0
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "deny"
        assert "exec is restricted for security reasons" in response_data["message"]

    def test_permission_tool_invalid_json(self):
        """Test permission_tool command handles invalid JSON input."""
        runner = CliRunner()

        # Test with invalid JSON
        result = runner.invoke(app, ["permission-tool", "bash", "invalid json"])

        assert result.exit_code == 1
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "deny"
        assert "Invalid JSON input" in response_data["message"]

    def test_permission_tool_response_models(self):
        """Test permission_tool response models are valid."""
        # Test allow response
        allow_response = PermissionToolAllowResponse(updatedInput={"command": "ls"})
        assert allow_response.behavior == "allow"
        assert allow_response.updated_input == {"command": "ls"}

        # Test deny response
        deny_response = PermissionToolDenyResponse(message="Tool is not allowed")
        assert deny_response.behavior == "deny"
        assert deny_response.message == "Tool is not allowed"

    def test_permission_tool_multiple_dangerous_patterns(self):
        """Test permission_tool command with multiple dangerous patterns."""
        runner = CliRunner()

        dangerous_patterns = [
            '{"command": "sudo rm -rf /"}',
            '{"path": "/etc/passwd", "content": "malicious"}',
            '{"command": "chmod 777 /etc"}',
            '{"command": "mkfs /dev/sda"}',
        ]

        for pattern in dangerous_patterns:
            result = runner.invoke(app, ["permission-tool", "bash", pattern])

            assert result.exit_code == 0
            response_data = self._extract_json_from_output(result.stdout)
            assert response_data["behavior"] == "deny"
            assert "dangerous pattern" in response_data["message"]

    def test_permission_tool_case_insensitive_tool_check(self):
        """Test permission_tool command is case insensitive for tool names."""
        runner = CliRunner()

        # Test uppercase restricted tool
        result = runner.invoke(
            app, ["permission-tool", "EXEC", '{"command": "echo hello"}']
        )

        assert result.exit_code == 0
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "deny"
        assert "EXEC is restricted for security reasons" in response_data["message"]

    @patch("ccproxy.cli.main.config_manager.load_settings")
    def test_permission_tool_settings_load_error(self, mock_load_settings):
        """Test permission_tool command handles settings loading errors."""
        runner = CliRunner()

        # Mock settings loading to raise an exception
        mock_load_settings.side_effect = Exception("Settings load error")

        result = runner.invoke(app, ["permission-tool", "bash", '{"command": "ls"}'])

        assert result.exit_code == 1
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "deny"
        assert "Error processing permission request" in response_data["message"]

    def test_permission_tool_complex_json_input(self):
        """Test permission_tool command with complex JSON input."""
        runner = CliRunner()

        complex_input = {
            "command": "echo",
            "args": ["hello", "world"],
            "options": {"verbose": True, "output": "/tmp/safe_file.txt"},
        }

        result = runner.invoke(
            app, ["permission-tool", "safe_tool", json.dumps(complex_input)]
        )

        assert result.exit_code == 0
        response_data = self._extract_json_from_output(result.stdout)
        assert response_data["behavior"] == "allow"
        assert response_data["updatedInput"] == complex_input

    def test_permission_tool_docstring(self):
        """Test permission_tool command has proper docstring."""
        assert permission_tool.__doc__ is not None
        assert "MCP permission prompt tool" in permission_tool.__doc__
        assert "Claude Code SDK" in permission_tool.__doc__
        assert "Examples:" in permission_tool.__doc__

    def test_permission_tool_parameter_types(self):
        """Test permission_tool command has correct parameter types."""
        import inspect

        sig = inspect.signature(permission_tool)

        # Check tool_name parameter
        tool_name_param = sig.parameters["tool_name"]
        assert tool_name_param.annotation is str

        # Check tool_input parameter
        tool_input_param = sig.parameters["tool_input"]
        assert tool_input_param.annotation is str
